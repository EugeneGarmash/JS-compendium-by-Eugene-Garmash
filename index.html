<!DOCTYPE html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<title>JavaScript compendium</title>
	<meta name="description" content="JS compendium written by some jerky coder">
	<meta name="keywords" content="JS, JavaScript, EcmaScript, JS5, JS6, JS7, JS8, programming, programming language">
	<meta name="author" content="Eugene Garmash">
 	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="normalize.css">
	<link rel="stylesheet" href="customResetEugeneGarmash.css">
	<link rel="stylesheet" href="style.css">
</head>

<body>

	<header>

		<nav class="navbar">
			<div class="navbar__nav-header">
				<h1>JavaScript compendium</h1>
				<p class="navbar-header__written-by">written by <br>
          <a href="https://github.com/EugeneGarmash">Eugene Garmash<sup>link</sup></a>
        </p>
        <p class="shown-when-mobile">Scroll down or click below to go to the section</p>
      </div>
			<ul class="navbar__list">
        <li>
          <a href="#general-information">
            Вступление
          </a>
        </li>
        <li>
          <a href="#conditions">
              Условия
          </a>
        </li>
        <li>
          <a href="#numbers-n-co">
            Числа, операторы и преобразование
          </a>
        </li>
        <li>
          <a href="#loops">
            Циклы
          </a>
        </li>
        <li>
          <a href="#arrays">
            Массивы
          </a>
        </li>
        <li>
          <a href="#functions"> 
            Функции
          </a>
        </li>
        <li>
          <a href="#strings">
            Строки
          </a>
        </li>
        <li>
          <a href="#closures">
            Замыкания
          </a>
        </li>
        <li>
          <a href="#objects">
            Объекты
          </a>
        </li>
        <li>
          <a href="#JS-n-browser">
              JS, HTML и браузер
          </a>
        </li>
        <li>
          <a href="#events">
            События
          </a>
        </li>
        <li>
          <a href="#JS-math">
            JS Math
          </a>
        </li>
        <li>
          <a href="#JS-time">
            JS time
          </a>
        </li>
      </ul>
    </nav>
    
  </header>


  <main>
    <h2 class="visually-hidden" id="to-top">Compendium text</h2>

    <section class="content-section" id="general-information">
      <h3>Вступление</h3>
      <section>
          <h4>Общая информация</h4>
          <p>Настоящее название – ECMAScript. DOM – Document Object Model </p>   
      </section>
      <section>     
        <h4>Комментарии</h4>
<pre>
  // Эта строка кода не выполнится. Однострочный комментарий.
  /*
  Все эти строки кода не выполнятся.
  Так как это многострочный комментарий.
  */
</pre>
      </section> 
      <section>
        <h4>Вывод в консоль:</h4>
<pre>
  console.log(переменные и действия);
  console.log('Привет от Кекса!');
  console.info;
</pre>
      </section>
      <section>
        <h4>Терминология на английском:</h4>
        <ul class="list-restored"> 
          <li>Инструкция  - statement</li>
          <li>присваивание – assignment</li>
          <li>выражение – expression</li>
          <li>значение – value</li>
          <li>пустое место – white space</li>
          <li>цикл – loop</li>
          <li>параметр – parameter</li>
          <li>аргумент – argument</li>
          <li>свойство объекта - property</li>
        </ul>
      </section>
      <section>
        <h4>Типы данных:</h4>
        <p> (Примитивные – типы данных, о которых можно сказать только то, чему они равны)</p>
        <ul class="list-restored">
          <li>number — числа (в JS числовой тип включает и целые, и дробные числа. В некоторых других языках это разные типы данных), Infinity, -Infinity and  Not a Number (NaN)</li>
          <li>string — строки, Тип символ не существует, есть только строка</li>
          <li>symbol</li>
          <li>boolean — логические или булевы значения, «истина» или «ложь»</li>
          <li>спец. знач. null – значение неизвестно. Null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно»</li>
          <li>специальное значение undefined – значение не присвоено / неопределено</li>
          <li>Массив (составной тип – несколько значений), array, хранит последовательность значений и порядок этих значений важен.
<pre>
  // Массив
  [1, 2, 3, 4, 5]
</pre>
          </li>
          <li>Объект (составной тип – несколько значений), object, состоит из множества пар «ключ-значение», порядок этих пар не важен
<pre>
  // Объект
  {
  month: 'june', 
  day: 15
  }
</pre>
          </li>
        </ul>
      </section>
      <section>
        <h4>Переменные</h4>
        <p>Переменная — название для данных, которое можно делать понятным для людей. Два самых популярных способа для названий: camelCase (верблюжья нотация) и snake_case (змеиная нотация; + венгерская нотация ( в имени указывают тип данных)).</p>
<pre>
  var имяПеременной;
  var someVariable;
</pre>
        <p>После создания переменной её можно использовать в других командах, например, выводить в консоль:</p>
<pre>
  // Обратите внимание, что кавычек нет!
  console.log(имяПеременной);
</pre>
        <p>Помимо объявления переменной нужно присвоить ей какие-то данные. Для операции присваивания используется знак равенства:</p>
<pre>
  var milkInGrams;              	// Объявляем переменную
  console.log(milkInGrams);     	// Выведет undefined
  milkInGrams = 20;             	// Присваиваем одно значение
  console.log(milkInGrams);     	// Выведет 20
</pre>
        <p>Команда var используется один раз, дальше обращаетесь к переменной без var. Если вы повторно задаёте значение переменной, вы меняете значение переменной. Объявление + присваивание: </p>
<pre>
  var milkCalories = 42;
  var dryFeedCalories = keks.ask('Сколько калорий в сухом корме?');
  var dailyMealInGrams = 50 + 80 + 120;
</pre>
        <p class="important">Важно:</p>
        <ul class="list-restored">
          <li>Имена переменных в JavaScript чувствительны к регистру. myname и myName — это две разных переменных.</li>
          <li>Имя переменной должно начинаться с латинской буквы и может содержать только латинские буквы и цифры (а также $ и _).</li>
          <li>В качестве имени переменной нельзя использовать специальные ключевые слова, такие как var или if (class, return, export и другие).</li>
          <li>Можно объявить несколько переменных сразу: 
<pre>
  var user = 'John', age = 25, message = 'Hello';
</pre>
          </li>
          <li> Присваивайте переменные в начале области видимости. Это помогает избегать проблем с объявлением переменных и областями видимости. Объявляйте переменные, которым не присваивается значение, в конце. Это удобно, когда вам необходимо задать значение одной из этих переменных на базе уже присвоенных значений.
<pre>
  // плохо
  var i, items = getItems(),
  dragonball,
  goSportsTeam = true,
  len;
  // хорошо
  var items = getItems(),
      goSportsTeam = true,
      dragonball,
      length,
      i;
</pre>
          </li>
        </ul>
      </section>
      <section>
        <h4>Операции</h4>
<pre>
  50 + 100;
</pre>
        <p>Это операция. Она состоит из знака операции, +, или оператора, и двух операндов, 50 и 100. Операция сложения — бинарная, так как в ней два операнда. Бинарные операции самые распространённые. Но существуют и унарные операции, с одним операндом, и тернарные операции, с тремя операндами. В качестве операндов можно использовать переменные:</p>
<pre>
  breakfastCalories + dinnerCalories;
  milkInGrams * 0.5;
  50 + waterInGrams;
</pre>
        <p>Над разными типами операндов можно производить разные операции, поэтому важно понимать, данные какого типа хранятся в переменных. И здесь очень помогает команда console.log(). Вот операции: Сложение (+), Вычитание (-), Умножение (*), Деление (/). А вот как результату операци присвоить переменную:</p>
<pre>
  var totalWaterInGrams = milkInGrams + waterInGrams;
</pre>
        <p>В одной команде можно использовать сразу несколько операций. Порядок выполнения операций будет зависеть от их приоритетов. Если в выражении есть только арифметические операции, то их приоритет такой же, как в школе: умножение и деление имеют высший приоритет, сложение и вычитание низший. У присваивания один из самых низких приоритетов. Именно поэтому, когда переменную чему-либо присваивают, например, x = 2 * 2 + 1 сначала выполнится арифметика, а уже затем – произойдёт присваивание =.</p>
      </section>
      <section>
        <h4>Операции со строками:</h4>
        <p>У каждого типа данных свои операции. Арифметические операции можно производить с числами, но не со строками. Самая важная строковая операция — это «склеивание» строк или конкатенация строк. Например:</p>
<pre>
  var name = 'Кекс';
  'Инструктор' + 'Кекс';  // результат: 'ИнструкторКекс'
  'Инструктор ' + 'Кекс'; // результат: 'Инструктор Кекс'
  'Инструктор ' + name;   // результат: 'Инструктор Кекс'  
</pre>
        <p>Что будет, если операнды разного типа?</p>
<pre>
  'Молоко, гр: ' + 50; 	// результат: 'Молоко, гр: 50'
  '2' * 50;            	// результат: 100 
</pre>
        <p>В этом случае JavaScript попытается привести операнды к одному типу и выполнить операцию. Подходящий тип будет выбираться в зависимости от операции. <br>
        - Плюс может быть знаком сложения или конкатенации, но так как один из операндов — строка, то сложение не подходит. Поэтому число 50 приводится к строке '50' и склеивается со строкой 'Молоко, гр: '. <br>
        - Звёздочка — это знак умножения. Поэтому JavaScript пытается превратить строку '2' в число, и у него это получается. Затем числа 2 и 50 перемножаются, и получается 100. <br>
        - Из-за того, что JavaScript умеет изменять тип операндов на лету, он называется языком с динамическим приведением типов. <br></p>
        <p class="important">Важно:</p>
        <p>Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!</p>
      </section>
      <section>
        <h4>Оператор typeof</h4>
        <p>возвращает тип аргумента (то, что в скобках). Синтаксис оператора: <br> 
            - typeof x <br>
            - typeof(x)
        </p>
      </section>
    </section>


    <section class="content-section" id ="conditions">
      <h3>Условия ("if" / ? / switch)</h3>
      <section>
        <h4>"if" statements</h4>
        <p>Представим, что нам нужно чтобы программа стала нелинейной: в зависимости от разных условий она должна выполнять разные команды. Для проверки условий используют условный оператор if:</p>
<pre>
  if (условие) {
  действия;
  }
</pre>
        <p>Здесь «условие» — это выражение, возвращающее true или false, а «действия» внутри фигурных скобок — это команды, которые выполняются, если условие удовлетворено.</p>
<pre>
  var foodInGrams = 60;
  var dayLimit = 80;
  if (foodInGrams &lt; dayLimit) {
      console.log('Ещё можно!');
  }
</pre>
      </section>
      <section>
        <h4>Else</h4>
<pre>
  if (условие) {
    действия;
  } else {
    другие действия;
  }            
</pre>
        <p>Ветка «действия» срабатывает, если условие выполнено. Ветка «другие действия» срабатывает, если условие не выполнено. "Если условие выполняется, сделай действие, иначе сделай другие действия".</p>
      </section>
      <section>
        <h4>Вложенные условия</h4>
        <p>Что делать, если принятие решения зависит не от одного, а от двух и более условий? Использовать один if, а затем, если условие выполнилось, выполнить ещё одно условие внутри вложенного if:</p>
<pre>
  if (условие1) {
    if (условие2) {
      действия;
    }
  }            
</pre>
      </section>
      <section>
        <h4>Else if</h4>
        <p>Бывает нужно проверить несколько вариантов условия. Для этого используется блок else if:</p>
<pre>
  var year = prompt('В каком году появилась спецификация ECMA-262 5.1?', '');         
  if (year &lt; 2011) {
    alert( 'Это слишком рано..' );
  } else if (year > 2011) {
    alert( 'Это поздновато..' );
  } else {
    alert( 'Да, точно в этом году!' );
  }            
</pre>
      </section>
      <section>
        <h4>Оперератор вопросительный знак ‘?’</h4>
        <p>условие ? значение1 : значение2 - для присваивания переменной в зависимости от условия</p>
<pre>
  var access;
  var age = prompt('Сколько вам лет?', '');
  var result = true ? 1 : 0;
  
  // Так будет долго:
  if (age > 14) {
    access = true;
  } else {
    access = false;
  }
  alert(access);

  // А вот так - коротко:
  access = (age > 14) ? true : false;

  var age = prompt('Сколько Вам лет?', '');
  var message = 
    (age &lt; 3) ? 'Здравствуй, малыш!':
    (age &lt; 18) ? 'Привет!':
    (age &lt; 100) ? 'Здравствуйте!':
    'Какой необычный возраст!';
</pre>
        <p class="important">Важно:</p>
        <p>Нельзя использовать break/continue справа от оператора „?“. Смысл оператора '?' – вернуть то или иное значение, в зависимости от условия. Пожалуйста, используйте его по назначению, а для выполнения разных веток кода есть if.</p>
      </section>
      <section>
        <h4>Switch</h4>
        <p>Конструкция switch заменяет собой сразу несколько if. Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.</p>
<pre>
  switch(x) {
    case 'value1':  // if (x === 'value1')
      ...
      [break]
    case 'value2':  // if (x === 'value2')
      ...
      [break]
    default:
      ...
      [break]
</pre>
        <ul class="list-restored">
          <li>Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.</li>
          <li>Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).</li>
          <li>Если ни один case не совпал – выполняется (если есть) вариант default.</li>
          <li>Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.</li>            
        </ul>
<pre>
  var a = 2 + 2; // Пример
  switch (a) {
    case 3:
      alert( 'Маловато' );
      break;
    case 4:
      alert( 'В точку!' );
      break;
    case 5:
      alert( 'Перебор' );
      break;
    default:
      alert( 'Я таких значений не знаю' );
  }            
</pre>
        <p>Группировка case</p>
<pre>
  case 3:                    // (*)
  case 5:                    // (**)
    alert('Неверно!');
    alert('Немного ошиблись, бывает.');
    break;
  // При case 3 выполнение идёт со строки (*), при case 5 – со строки (**).
</pre>
        <p class="important">Важно:</p>
        <p>Оператор switch предполагает строгое равенство (рассмотрено дальше, ===).</p>
      </section>
      <section>
        <h4>Задания</h4>
        <ol class="ordered-list-restored">
          <li>
            <p>Программа должна анализировать числа. Если число делится на 3, результат работы программы — строка 'Fizz'. Если число делится на 5 — строка 'Buzz'. Если число одновременно делится на 3 и на 5 — результат 'FizzBuzz'. В остальных случаях результат работы программы — изначальное число. Число записано в переменную number. Результат работы программы записывайте в переменную taskResult. </p>
<pre>
    var number = 15;
    var taskResult;    
</pre>
            <label class="question" for="conditions1">Показать ответ</label>
            <input type="checkbox" id="conditions1" class="visually-hidden">
<pre>
  1
  if (number % 3 == 0 && number % 5 == 0) {
    taskResult = 'FizzBuzz';
  } else if (number % 3 == 0) {  // или вместо равнения к нулю ставить (!...) 
    taskResult = 'Fizz';
  } else if (number % 5 == 0) {
    taskResult = "Buzz";
  } else {
    taskResult = number;
  }
  2 - креативно
  var fizz = number % 3;
  var buzz = number % 5;
  taskResult = number;
  var fizz = ...; 
  var buzz = ...;
  var fizzbuzz = ...;
    if (!fizz) {
  taskResult = 'Fizz';
  }
  if (!buzz) {
  taskResult = 'Buzz';
  }
  if (!fizz && !buzz) {
  taskResult = 'FizzBuzz';
  }
  3 - короче всего
  taskResult = number;
  if (!(number%3) && (number%5)) {
    taskResult = "Fizz";
  }
  if (number%3 && !(number%5)) {
    taskResult = "Buzz";
  }
  if (!(number%3) && !(number%5)) {
    taskResult = "FizzBuzz";
  }
</pre>
          </li>
          <li>
            <p>Напиши программу, которая будет рассчитывать сумму покупки с учётом скидки. Если стоимость покупки от 1000 (включительно) до 3000 (не включая это значение), скидка составляет 5%. Если стоимость покупки от 3000 (включительно) до 5000 (не включая это значение), скидка 10%. Если стоимость покупки от 5000 (включительно) и выше, скидка 15. В остальных случаях скидки для покупателей нет. Вычисляй стоимость с учётом скидки и записывай результат в переменную discountedBuy. Для того чтобы проверить код создай переменную buy до условия и меняй в ней значения, результат выводи в консоль либо alert(...)</p>
            <label class="question" for="conditions2">Показать ответ</label>
            <input type="checkbox" id="conditions2" class="visually-hidden">
<pre>
  if (buy &lt; 1000) {
    discountedBuy = buy;
  } else if (buy >= 1000 && buy &lt; 3000) {
    discountedBuy = buy * 0.95;
  } else if (buy >= 3000 && buy &lt; 5000) {
    discountedBuy = buy * 0.90;
  } else {
    discountedBuy = buy * 0.85;
  }                
</pre>
          </li>
          <li>
            <p> Напиши программу для расчёта длительности прогулки. Она зависит от нескольких условий. Если идёт дождь, гулять я не хожу. В этом случае длительность прогулки равняется 0. А вот если дождя нет, всё зависит от температуры на улице: Во-первых, если температура от 10°C (включительно) до 15°C (не включая это значение), я гуляю 30 минут. Во-вторых, если температура от 15°C (включительно) до 25°C (не включая значение), я гуляю 40 минут. В-третьих, при температуре от 25°C (включительно) до 35°C (включительно), я гуляю 20 минут. В остальных случаях я никуда не выхожу: либо очень холодно, либо очень жарко. Результат программы – время прогулки. Его необходимо записать в переменную minutes.</p>
<pre>
    // переменные для твоего кода
    var temperature = 20; // меняй чтобы проверить
    var itsRaining = false; // меняй для другого результата
    var minutes;
</pre>
            <label class="question" for="conditions3">Показать ответ</label>
            <input type="checkbox" id="conditions3" class="visually-hidden">
<pre>
// 1
  if (isRaining || temperature &lt; 0 || temperature > 35) {
    minutes = 0;
  } else if (temperature >= 10 && temperature &lt; 15) {
    minutes = 30;
  } else if (temperature >= 15 && temperature &lt; 25) {
    minutes = 40;
  } else {
    minutes = 20;
  }
// 2 - хуже, но тоже логично
  if (!isRaining) {
    if (10 &lt;= temperature && temperature &lt; 15) {
      minutes = 30;
    }
    if (15 &lt;= temperature && temperature &lt; 25) {
      minutes = 40;
    }
    if (25 &lt;= temperature && temperature &lt;= 35) {
      minutes = 20;
    }
    if (10 > temperature || temperature > 35) {
      minutes = 0;
    }
  } else {
    minutes = 0;
  }
// 3 - самый продвинутый вариант
if (itsRaining == true || temperature &lt; 0 || temperature > 35) {
  minutes = 0;
} else {
  minutes = 20 -  Math.abs(temperature - 20);
}
</pre>
          </li>
        </ol>
      </section>
    </section>
    
    
    <section class="content-section" id="numbers-n-co">
      <h3>Числа, операторы и преобразование</h3>
      <section>
        <h4>Операторы «больше» > и «меньше» &lt;, «больше или равно» >=, «меньше или равно» &lt;=</h4>
        <p>Как и другие операторы, сравнение возвращает значение. Это значение имеет логический тип ‘False’ or ‘True’: </p>
<pre>
  if (red &lt; yellow) {
    console.log('Красные маркеры в меньшинстве. Прогноз умеренно позитивный!');
  } else {
    console.log('Неправильно! Прогноз неприемлем!');
  }
</pre>
        <p>Строки сравниваются побуквенно. В кодировке Unicode обычно код у строчной буквы больше, чем у прописной, поэтому регистр имеет значение. Для корректного сравнения символы должны быть в одинаковом регистре. Если строка состоит из нескольких букв, то сравнение осуществляется как в словаре.</p>
<pre>
  alert( 'Б' > 'А' ); // true
  alert( 'Банан' > 'Анна' );
  alert( 'Вася' > 'Ваня' ); // true, т.к. 'с' > 'н'
  alert( 'Привет' > 'Прив' ); // true, так как 'е' больше чем "ничего".
</pre>
        <p>Числа и строки сравнивать нельзя, результат будет неверен. В примере ниже 2 оказалось больше 14, потому что строки сравниваются посимвольно, а первый символ '2' больше '1'. Правильно было бы преобразовать их к числу явным образом. Например, поставив перед ними +. При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям.</p>
<pre>
  alert( "2" > "14" ); // true, неверно, ведь 2 не больше 14
  alert( +"2" > +"14" ); // false, теперь правильно

  alert( '2' > 1 ); // true, сравнивается как 2 > 1
  alert( '01' == 1 ); // true, сравнивается как 1 == 1
  alert( false == 0 ); // true, false становится числом 0
  alert( true == 1 ); // true, так как true становится числом 1.
</pre>
      </section>
      <section>
        <h4>Равенство</h4>
        <img src="images/comparison.png" alt="comparison">
<pre>
  console.log('123' == 123); // Выведет true
  console.log('123' != 123); // Выведет false            
</pre>
        <p>Строка и число окажутся равны друг другу. Так происходит, потому что при сравнении разных типов с помощью == происходит преобразование значений к единому типу. Из строки '123' можно получить число 123. По этой же причине неравенство != возвращает для этих значений false.</p>
        <p class="important">Важно: </p>
        <p>.</p>
        <img src="images/comparison__2.png" alt="comparison__2">
        <ul>
          <li>Числа и строки приводятся по-особому. Например, все числа кроме 0 — true, при этом 0 — false. Все строки, кроме пустой строки — true, пустая строка '' — false. Можно сказать, что значения, которые как бы ничего в себе не содержат (как 0 или пустая строка ), приводятся к false, а все остальные приводятся к true. Кратко говоря, число 0, пустая строка "", null и undefined, а также NaN являются false. Все остальное – true</li>
          <li>Преобразование null и undefined. Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка. При преобразовании в число null становится 0, а undefined становится NaN. Дело в том, что алгоритмы проверки равенства == и сравнения >= > &lt; &lt;= работают по-разному. Сравнение честно приводит к числу, получается ноль. А при проверке равенства значения null и undefined обрабатываются особым образом: они равны друг другу, но не равны чему-то ещё. Значение undefined вообще нельзя сравнивать, всегда будет false кроме null.Сравнение приводит null к числу  (0), а равенство  - нет.
          Вывод: любые сравнения с undefined/null, кроме точного ===, следует делать с осторожностью. Желательно не использовать сравнения >= > &lt; &lt;= с ними, во избежание ошибок в коде.
<pre>
  alert( null > 0 ); // false
  alert( null == 0 ); // false
  alert(null >= 0); // true                
</pre>
          </li>
          <li>Использовать строгое равенство — хорошая практика. Используйте именно его во всех случаях, где это возможно</li>
        </ul>
      </section>
      <section>
        <h4>Операторы %, + (унарный плюс) и запятая, приоритет операторов</h4>
        <p>Приоритет операторов:</p>
        <img src="images/priority.png" alt="priority">
        <img src="images/priority__2.png" alt="priority__2">
        <img src="images/priority__3.png" alt="priority__3">
        <p>% - оператор «остаток от деления» - возвращает остаток от деления чисел. Работает это так:</p>
<pre>
  12 % 5;  // Вернёт 2	
  27 % 3;  // Вернёт 0
  13 % 3;  // Вернёт 1            
</pre>
        <p>Оператор “унарный плюс”. Так как «унарный плюс» имеет приоритет 15, выше, чем 13 у обычного «сложения», то в выражении +apples + +oranges сначала сработали плюсы у apples и oranges, а затем уже обычное сложение. «Побочный эффект унарного плюса» – преобразование значения в число. Например, когда мы получаем значения из HTML-полей или от пользователя, то они обычно в форме строк. Его «побочный эффект» – преобразование значения в число. А что, если их нужно, к примеру, сложить? Бинарный плюс сложит их как строки:</p>
<pre>
  var apples = "2";
  var oranges = "3";
  alert( +apples + +oranges ); // 5, число, оба операнда предварительно преобразованы в числа            
</pre>
        <p>Оператор запятая. Запятая – единственный оператор, приоритет которого ниже присваивания. В выражении a = (5,6) для явного задания приоритета использованы скобки, иначе оператор '=' выполнился бы до запятой ',', получилось бы (a=5), 6.</p>
      </section>
      <section>
        <h4>Проверка на число и неЧисло</h4>
        <p>Проверка на число. <br> isNaN(n) преобразует аргумент к числу и возвращает true для NaN, и false для остальных.</p>
<pre>
  var n = 0 / 0;
  alert( isNaN(n) ); // true
  alert( isNaN("12") ); // false, строка преобразовалась к обычному числу 12
  /////
  var x = prompt("Введите значение", "-11.5");
  if (isNaN(x)) {
    alert( "Строка преобразовалась в NaN. Не число" );
  } else {
    alert( "Число" );
  }
</pre>
        <p class="important">Важно:</p>
        <p>Пустая строка и строка из пробельных символов преобразуются к 0, поэтому считаются числами. Если применить такую проверку не к строке, то могут быть сюрпризы, в частности isNaN посчитает числами значения false, true, null, так как они хотя и не числа, но преобразуются к ним.</p>
<pre>
  alert( isNaN(null) ); //  false - не NaN, т.е. "число"
  alert( isNaN("\n  \n") ); //  false - не NaN, т.е. "число"
</pre>
        <p>Проверка на неЧисло. <br> isFinite(n) – true для числа, false для (NaN, Infinity, -Infinity, пустая строка). - преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity</p>
<pre>
  alert( isFinite(1) ); // true
  alert( isFinite(Infinity) ); // false
  alert( isFinite(NaN) ); // false
</pre>
        <p>isNumeric – специальная функция. Точная проверка на число, которая не считает числом строку из пробелов, логические и специальные значения, а также отсекает Infinity.</p>
<pre>
  function isNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }            
</pre>
        <ul>
          <li>- Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не Infinity/-Infinity/NaN.</li>
          <li>Таким образом, правая часть отсеет заведомо не-числа, но оставит такие значения как true/false/null и пустую строку '', так как они корректно преобразуются в числа.</li>
          <li>Для их проверки нужна левая часть. Вызов parseFloat(true/false/null/'') вернёт NaN для этих значений.</li>
          <li>Так устроена функция parseFloat: она преобразует аргумент к строке, то есть true/false/null становятся "true"/"false"/"null", а затем считывает из неё число, при этом пустая строка даёт NaN.</li>
        </ul>
      </section>
      <section>
        <h4>Преобразования</h4>
        <p><b>A. Строковое:</b> String(value) – в строковом контексте или при сложении со строкой. Работает очевидным образом.</p>
        <p>1. String(someValue)</p>
        <p>2. Для явного преобразования применяется и оператор "+", у которого один из аргументов строка. В этом случае он приводит к строке и другой аргумент, например:</p>
<pre>
  alert( true + "test" ); // "truetest"
  alert( "123" + undefined ); // "123undefined"            
</pre>
        <p>3. число.toString() и toString(основание системы) - converts a number to a string. При помощи такого кодирования можно «укоротить» длинный цифровой идентификатор, например чтобы выдать его в качестве URL.</p>
<pre>
  var number = 1;
  console.log(number); 		// Выведет число: 1 (number)
  console.log(number.toString()); 	// Выведет строку: "1" (string)
  var n = 4;
  alert( n.toString(2) ); // 100
  var n = 1234567890;
  alert( n.toString(36) ); // kf12oi 
  var n = 255;
  alert( n.toString(16) ); // ff            
</pre>
        <p><b>B. Численное:</b></p>
        <p>1. Number(val)</p>
        <p>2. Строгое преобразование к числу используя + .Если строка не является в точности числом, то результат будет NaN. Единственное исключение – пробельные символы в начале и в конце строки, которые игнорируются:</p>
<pre>
  alert( +"12test" ); // NaN
  alert( +"  -12" ); // -12
  alert( +" \n34  \n" ); // 34, перевод строки \n является пробельным символом
  alert( +"" ); // 0, пустая строка становится нулем
  alert( +"1 2" ); // NaN, пробел посередине числа – ошибка
  var a = +"123"; // 123
  var a = Number("123"); // 123, тот же эффект            
</pre>
        <p>3. Мягкое преобразование: parseInt и parseFloat – преобразует посимвольно пока может. В мире HTML/CSS многие значения не являются в точности числами. Например метрики CSS: 10pt или -12px. Оператор '+' для таких значений возвратит NaN:  alert(+"12px") // NaN. Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно. При возникновении ошибки возвращается число, которое получилось. Функция parseInt читает из строки целое число, а parseFloat – дробное. существуют ситуации, когда При ошибке на первом же символе parseInt/parseFloat возвращают NaN.</p>
<pre>
  alert( parseInt('12px') ) // 12, ошибка на символе 'p'
  alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке
  alert( parseInt('a123') ); // NaN
</pre>
        <p>Функция parseInt также позволяет указать систему счисления, то есть считывать числа, заданные в шестнадцатиричной и других системах счисления. Обратите внимание, что у команды два аргумента: - строка, которую мы пытаемся превратить в число; - основание системы счисления, в которую мы переводим число.</p>
<pre>
  alert( parseInt('FF', 16) ); // 255
</pre>
        <p>В JavaScript можно записывать числа не только в десятичной, но и в шестнадцатеричной системе счисления и в других. Если математическая операция не может быть совершена, то возвращается специальное значение NaN. Пустая строка преобразуется в ноль.</p>
<pre>
  alert( 0xFF ); // 255 в шестнадцатиричной системе, всегда добавляем 0x
</pre>
        <p>C. Логическое: Boolean(value) – в логическом контексте, можно также сделать двойным НЕ: !!value.</p>
<pre>
  !! ‘о’ === false;
  !! 1 === true;
</pre>
      </section>
      <section>
        <h4>Логические операторы математической (булевой) логики: &&, || и !</h4>
<pre>
  var conditionOne = true;
  var conditionTwo = true;
  var conditionThree = false;
  var conditionFour = true;
  if (conditionOne && conditionTwo) {
  // код выполнится
  }
  if (conditionThree || conditionFour) {
  // код тоже выполнится
  }
</pre>
        <p>Оператор && или «логическое И» возвращает true только в том случае, если оба условия, слева и справа от него, возвращают true. Оператор || или «логическое ИЛИ» возвращает true если любое из условий слева или справа от него, возвращают true. || запинается на «правде». && запинается на «лжи», || - на правде Приоритет у && больше, чем у ||</p>
        <p>Логическое отрицание.Чтобы создать проверки с отрицанием используют унарный (одноместный) логический оператор !. Пример:</p>
<pre>
  var condition = false;
  if (!condition) {
    // код выполнится
  }
  var conditionOne = true;
  var conditionTwo = true;
  var conditionThree = false;
  if (conditionOne && conditionTwo && !conditionThree) {
    // код выполнится
  }
</pre>
      </section>
    </section>
    

    <section class="content-section" id="loops">
      <h3>Циклы</h3>
      <section>
        <h4>Рекурсия</h4>
<pre>
  var washNextItem = function(itemsLeft) {
    itemsLeft --;
    console.log('Осталось ' + itemsLeft);
    if (itemsLeft > 0) {
      washNextItem(iemLeft);
    }
  }
  washNextItem(10);              
</pre>
      </section>
      <section>
        <h4>For Loop</h4>
<pre>
  // Переменная хранит нужное количество копий
  var page = 7;
  var count = 5;
  // можно без цикла:
  if (count === 5) {
    keks.print(page);
    keks.print(page);
    keks.print(page); 
    keks.print(page);
    keks.print(page);
  }
  // но лучше с ним
  for (var i = 0; i &lt; count; i = i + 1) { 
    keks.print(page); // повторяющиеся команды или «тело цикла» - команда
  }
  //       1       2      4
  for (var i = 0; i &lt; 10; i ++) {
      console.log([…]);        //  3
  }              
</pre>
        <p>Смысл каждой части в скобках следующий такой:</p>
        <p>1. Первая часть — подготовительная. Команда запускаются один раз перед началом работы цикла,  задаётся исходное значение для переменной-счётчика. Обратите внимание, что в цикле мы создаём переменную-счётчик с помощью var, как в случае с любой другой переменной. Традиционно такая переменная называется i (от слова index), но у неё может быть любое другое название (day, page etc.).</p>
        <p>2. Вторая часть — проверочная. Она содержит условие и запускается перед каждым новым витком цикла. Условие здесь работает по знакомому вам алгоритму. Если условие возвращает true, цикл делает ещё один виток, иначе цикл завершает свою работу. </p>
        <p>4. Тело цикла - необходимый к выполнению код</p>
        <p>3. Третья часть — дополняющая, по-научному она называется «законом изменения». Код третьей части запускается после каждого витка цикла. То есть после того, как выполнится код из тела цикла. Обычно там изменяется переменная-счётчик.</p>   
<pre>
  //Начало  → Условие (true) → Выражение → Шаг
  //	      Условие (false) → X
  // «Делать до тех пор как [true]».

  // Еще примеры:
  // Пять копий одной страницы
  var page = 7;
  var count = 5;
  for (var i = 0; i &lt; count; i = i + 1) {
    console.log(page);  
  }
  // Печать страниц с первой по пятую
  var totalPages = 5;
  for (var page = 1; page &lt;= totalPages; page = page + 1) {
    console.log(page);
  }
  // Печать страниц в обратном порядке
  var totalPages = 5;
  for (var page = totalPages; page > 0; page = page - 1) {
    console.log(page);
  }
</pre>
        <p>Можно убрать начало (1). <br> Можно убрать и шаг(2). <br> А можно и вообще убрать всё, получив бесконечный цикл(3).</p>
<pre>
  // 1
    var i = 0;
    for (; i &lt; 3; i++) {    // тоже что и for (i = 0; i &lt; 3; i++)
      alert( i ); // 0, 1, 2
    }
  // 2 -- цикл превратился в аналог while (i &lt; 3) 
    var i = 0;
    for (; i &lt; 3;) {
      alert( i );
      // 
    }
  // 3
    for (;;) {
      // будет выполняться вечно
    }
</pre>
      </section>
      <section>
        <h4>Инкременты и декременты</h4>
<pre>
  // Инкремент: i++ аналог i = i + i
  Декремент: i-- аналог i = i - i
  Комбо: i+=2 аналог i = i + 2
</pre>
        <p>Комбинировать можно не только сложение, но и остальные математические операции: вычитание -=, умножение *=, деление /= и нахождение остатка %=. Например, i *= 10 будет аналогично i = i * 10. Постфиксная форма i++ отличается от префиксной ++i тем, что возвращает старое значение, бывшее до увеличения.  Инкремент/декремент можно применить только к переменной. Код 5++ даст ошибку.</p>
      </section>
      <section>
        <h4>накопление в цикле</h4>
        <p>Нужно завести перед циклом ещё одну переменную, которая будет хранить информацию</p>
<pre>
  var sum = 0;
    for (var i = 1; i &lt;= 5; i++) {
    sum += 2;
    console.log(sum);
  }
  /*
  Программа выведет:
  LOG: 2 (number)
  LOG: 4 (number)
  LOG: 6 (number)
  LOG: 8 (number)
  LOG: 10 (number)
  Цикл выполняет операцию столько раз, сколько это предусмотрено самим циклом.
  */              
</pre>
      </section>
      <section>
        <h4>Проверки в циклах (if в for)</h4>
        <p>Например, можно проверять значение счётчика, и если оно больше двух, прибавлять к сумме 3, а не 2.</p>
<pre>
  var sum = 0;
  for (var i = 1; i &lt;= 5; i++) {
    if (i > 2) {
      sum += 3;
    } else {
      sum += 2;
    }
    console.log(sum);
  }
</pre>
      </section>
      <section>
        <h4>While Loop</h4>
<pre>
  while (условие) {
    действия
  }
</pre>
        <p>Действия, указанные в цикле, будут выполняться снова и снова, пока условие не вернёт false.</p>
<pre> 
  i = 10;
  while(i > 0) {
    console.log(i);
    i--;
  }
</pre>
      </section>
      <section>
        <h4>break / continue</h4>
        <p>помнить: нельзя использовать справа от оператора „?“. break прерывает исполнение цикла. Внутри while команда continue «перематывает» программу сразу к началу следующей итерации. Внутри for команда continue «перематывает» программу к дополнительной части текущей итерации, после выполнения которой начинается следующая итерация цикла.</p>
        <p>Метки для break/continue. Бывает нужно выйти одновременно из нескольких уровней цикла. Например, внутри цикла по i находится цикл по j, и при выполнении некоторого условия мы бы хотели выйти из обоих циклов сразу:</p>
<pre>
  outer: for (var i = 0; i &lt; 3; i++) {
    for (var j = 0; j &lt; 3; j++) {
    var input = prompt('Значение в координатах '+i+','+j, '');
        // если отмена ввода или пустая строка -
        // завершить оба цикла
        if (!input) break outer; // (*)
      }
    }
    alert('Готово!');              
</pre>
      </section>
      <section>
        <h4>Другие виды циклов</h4>
<pre>
  // 1-- for - обычный цикл, ничего не возвращает, производит действие в теле 
  // 2-- while - пока условие истинно. do...while - то же самое. 

  // for...of - для перебора данных, например, значений массива. Он также работает с большинством массивоподобных объектов, вроде списковNodeList в DOM.
  // Работает с break, continue и return.

  // 3-- <b>array.forEach</b> - метод циклов для перебора, ничего не возвращает, тот же for
  var names = ['HTML', 'CSS', 'JavaScript'];
  var arr = [];
  names.forEach(function(item, i, array) {
    arr.push(' Длина '+ item + ': ' + item.length);
    console.log('Элемент ' + item + ', индекс ' + i);
  });
  console.log('array.forEach --> ' + arr);
  // Но не работает с break, continue и return.
  // Еще пример: 
  let products = [
    { name: 'Running shoes', price: 75 },
    { name: 'Golf shoes',    price: 85 },
    { name: 'Dress shoes',   price: 95 },
    { name: 'Walking shoes', price: 65 },
    { name: 'Sandals',       price: 55 }
  ];
  products.forEach((product, index) => {
    console.log(product);
  });
  // и еще
  var students = ['Eugene', 'Julia', 'Michael'];
    students.forEach(function(student) {
  });

  // <b>for loop vs forEach loop</b>
  for (let i = 0; i &lt; products.length; i++) {
    let product = products[i];
    console.log(product);
    for (let j = 0; j &lt; product.sizes.length; j++) {
      let size = product.sizes[j];
      console.log(size);
    }
  }
  products.forEach((product) => {
    product.sizes.forEach((size) => {
      console.log(size);
    });
  });
  // when you want to break out of a loop early, use 'for'. If you used forEach(), it would iterate over every single product resulting in unnecessary iterations
  for (let i = 0; i &lt; products.length; i++) {
    if (matchesSomeCriteria(products[i])) {
      doSomething();
      break;
    }
  } 

  /* 4-- метод <b>arr.map(callback[, thisArg])</b> метод массива используется для трансформации массива. Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr. Позволяет создать новый массив, основанный на каким-то образом обработанных значениях другого массива.*/
  var names = ['HTML', 'CSS', 'JavaScript'];
  var nameLengths2 = names.map(function(name) {
    return name.length;
  });
  console.log('array.map --> ' + nameLengths2); // вернет массив из длины элементов
  //  или так:
  const numbers = [2, 3, 4, 5];
  const dollars = numbers.map( number => '$' + number);
  // Вот как будет выглядеть массив dollars: ['$2', '$3', '$4', '$5']
  // еще: 
    const schools = [
    "Yorktown",
    "Washington & Lee",
    "Wakefield"
  ]
  const highSchools = schools.map(school => ({ name: school }))
  console.log(highSchools) // вернёт массив из трёх объектов

  /* 5-- <b>arr.filter</b> - фильтрация массива - cоздаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) / которые соответствуют заданному условию.
  возвратит true. */
  var someArr = [10,20,30,40,50,60,70,80,90];
  var newArr = someArr.filter(function(item) {
    return item > 50;
  });
  console.log('arr.filter --> ' + newArr);
  console.log('_____');
  // или так:
  const studentsAge = [17, 16, 18, 19, 21, 17];
  const ableToDrink = studentsAge.filter( age => age > 18 );
  // Массив ableToDrink будет содержать два значения: [19, 21]
  // Еще пример:
  const schools = [
    "Yorktown",
    "Washington & Lee",
    "Wakefield"
  ]
  const wSchools = schools.filter(school => school[0] === "W")
  console.log( wSchools ) // ["Washington & Lee", "Wakefield"]
  //!! При решении задач по удалению элемента из массива нужно пользоваться функцией Array.filter, а не Array.pop или Array.splice, потому что она не вносит в данные никаких изменений.
  const array = [0, 1, 2, 3, 4, 5, 6, 7, 8];
  const newArray = array.splice(-1);
  console.log(array); // [0, 1, 2, 3, 4, 5, 6, 7]
  console.log(newArray); // [8]
  console.log('**')
  const array = [0, 1, 2, 3, 4, 5, 6, 7, 8];
  const newArray = [...array].splice(-1);
  console.log(array); // [0, 1, 2, 3, 4, 5, 6, 7, 8]
  console.log(newArray); // [8]
  console.log('__');
  
  /* 6-- <b>every/some</b> - возвращает true, если вызов callback вернёт true для каждого/какого-нибудь элемента arr.*/
  var arr = [1, -1, 2, -2, 3];
  function isPositive(number) {
    return number > 0;
  }
  console.log(arr.every(isPositive)); // false, не все положительные
  console.log(arr.some(isPositive)); // true, есть хоть одно положительное

  /* 7-- <b>reduce/reduceRight</b> – для прохода по массиву с вычислением значения. */
  var numbers = [1,2,3,4,5,6,7,8,9,0];
  // var sum = 0;
  // for (var i = 0; i &lt; numbers.length; i ++) {
  //   sum += numbers[i];
  // }
  // console.log(sum);
  // console.log('_____');
  var result = numbers.reduce(function(sum, current) {
    console.log('всего: ' + (sum + current))
    return sum + current;
  }, 0); // можно и без нуля, перебор стартует со второго элемента
  console.log(result);

  const numbers = [5, 10, 15];
  const total = numbers.reduce( (accumulator, currentValue) => accumulator + currentValue);
  // в константу total будет записано число 30

</pre>
      </section>
    </section>


    <section class="content-section" id="arrays">
      <h3>Массивы</h3>

      <section>
        <h4>Общее</h4>
        <p>Массив — это тип данных, который представляет собой список элементов, у каждого из которых есть свой порядковый номер. Массивы создаются с помощью квадратных скобок. Внутри скобок через запятую перечисляются все значения, которые должен содержать массив. При создании массив, как любое значение, можно записать в переменную. В массиве можно хранить любые данные: строки, булевы значения, числа и даже другие массивы. Одно из применений массива – это очередь. В классическом программировании так называют упорядоченную коллекцию элементов, такую что элементы добавляются в конец, а обрабатываются – с начала. Очень близка к очереди еще одна структура данных: стек. Это такая коллекция элементов, в которой новые элементы добавляются в конец и берутся с конца. Например, стеком является колода карт, в которую новые карты кладутся сверху, и берутся – тоже сверху.</p>
<pre>
  var numbers = [1, 2, 3, 4, 5]; // массив
</pre>
        <p>Чтобы получить <b>элемент массива</b>, нужно в квадратных скобках указать порядковый номер или индекс этого элемента. Нумерация элементов в массиве начинается с нуля: первый элемент массива идёт под номером ноль, второй — под номером один, третий — два и так далее. В скобках можно записывать что угодно, главное чтобы получалось число.</p>
<pre>
  var numbers = [1, 2, 3, 4, 5];
  console.log(numbers[1]); // Выведет в консоль 2
  var some = 4
  console.log(numbers[some]); // выведет в консоль 5            
</pre>
        <p><b>Длина массива</b>. Массивы умеют рассказывать о своей длине. Для этого используется команда [].length:</p>
<pre>
  var numbers = [1, 2, 3, 4];
  console.log(numbers.length);
  // Выведет в консоль 4            
</pre>
        <p>С помощью обращения к length можно получить <b>последний элемент массива</b>, даже если вы не знаете, сколько элементов в нём хранится. Допустим, в этом большом массиве 100 элементов. Его длина будет равна 100. Индекс последнего, сотого, элемента будет равен 99 потому что нумерация в массивах начинается с нуля. Поэтому индекс последнего элемента вычисляется вычитанием единицы из длины. Длина (length) – не количество элементов массива, а последний индекс + 1.</p>
<pre>
  someBigArray[someBigArray.length - 1]; // последний элемент массива

  // Используем length для укорачивания массива
  var arr = [1, 2, 3, 4, 5];
  arr.length = 2; // укоротить до 2 элементов
  alert( arr ); // [1, 2]
  arr.length = 5; // вернуть length обратно, как было
  alert( arr[3] ); // undefined: значения не вернулись
</pre>
      </section>
      <section>
        <h4>Циклы и массивы</h4>
        <p>Начальный индекс у массива мы знаем. Он равен нулю. Индексы в массиве возрастают на единицу. Использовать переменную в качестве индекса можно. Получается, что мы можем задать переменной нулевое значение, а затем использовать её в цикле для доступа к элементам массива, наращивая в каждой итерации на единицу. Переменная цикла будет использоваться как индекс элементов массива. Поэтому зададим ей нулевое значение и будем увеличивать в каждой итерации на единицу, пока её значение не станет равным индексу последнего элемента.</p>
<pre>
  for (var i = 0; i &lt; someArray.length; i ++) {
    console.log(someArray[i]) // Выводим в консоль элементы массива, пока 
  }
  // или так:
  for (var i = 0; i &lt;= someArray.length - 1; i ++) {
    console.log(someArray[i]) // Выводим в консоль элементы массива, пока 
  }
</pre>
      </section>
      <section>
        <h4>Запись в массив</h4>
        <p>Запись в массив происходит так же, как и чтение — через обращение к элементу с помощью квадратных скобок. Обратите внимание, что если в массиве нет элемента под тем номером, под которым мы записываем, то этот элемент будет создан. До выполнения кода в массиве не было ни нулевого, ни первого элементов, но после того, как мы записали значения в эти позиции, элементы добавились в массив.</p>
<pre>
  var numbers = [];
  var index = 1;
  numbers[0] = 1;
  numbers[index] = 2;
  // Выведет [1,2]
  console.log(numbers);            
</pre>
      </section>
      <section>
        <h4>Многомерные массивы</h4>
        <p>Массивы в JavaScript могут содержать в качестве элементов другие массивы. Это можно использовать для создания многомерных массивов, например матриц:</p>
<pre>
  var arr = [
    [1,2,3],
    [4,5,6],
    [7,8,9],
    [[10,11,12], 13, 14]
  ];
  arr[3]; // equals [[10,11,12], 13, 14]
  arr[3][0]; // equals [10,11,12]
  arr[3][0][1]; // equals 11          
</pre>
        <p class="important">Важно:</p>
        <p>Не используйте for..in (рассматривается ниже) для массивов. Цикл for..in выведет все свойства объекта, а не только цифровые (да, у массива есть и другие свойства - об этом ниже). Цикл for выполняется в 10-100 раз быстрее.</p>
      </section>        
      <section>
        <h4>arr.indexOf() & arr.lastIndexOf()</h4>
        <p>Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или -1, если его нет. Для поиска используется строгое сравнение ===. Можем найти строку из одного символа, если обратиться ко всей строке, используя индекс переменная[0]:</p>
<pre>
  var string = 'Меня зовут Кекс'; // Записываем строку в переменную
  console.log(string[5]); // Ищем шестой элемент в строке → Вернёт 'з'
  string.indexOf('Кекс') // Ищем, есть ли в строке подстрока 'Кекс' → Вернёт 11          
  
  var numbers = [2, 5, 9, 2];
  numbers.lastIndexOf(2);     // 3
</pre>
        <p>По синтаксису эти методы аналогичны методу indexOf() / lastIndexOf() для строк.</p>
      </section>
      <section>
        <h4>Быстрый поиск по массиву: это интересно</h4>
          <img src="images/Arrays__array-to-object.png" alt="array-to-object">
<pre>
  var some = {};
  var items = ['for', 'a', 'div'];
  for (var i = 0; i &lt; items.length; i ++) {
    var key = items[i];
    some[items[i]] = true;
  }
  if(some['dip']) {
    console.log('YES');
  } else {
    console.log('NO');
  }              
</pre>
      </section>
      <section>
        <h4>Псевдомассивы</h4>
        <p>Псевдомассив — это объект, который структурно похож на массив. То есть у него есть числовые свойства (индексы) и свойство length. Их мы получаем, к примеру, когда ищем несколько селекторов сразу (поиск по HTML описан ниже). Важно то, что псевдомассивы не отвечают на методы массивов, но псевдомассив можно превратить в нормальный массив при помощи методов slice или Array.from() (описаны ниже).</p>
<pre>
  var elems = document.documentElement.childNodes;
  elems = Array.prototype.slice.call(elems); // теперь elems - массив
</pre>
      </section>
      <section class="">
        <h4>Методы массивов</h4>
<pre>

  var someArray = [1,'a', 'someNoun', 6894, [0,2,4,6]];
  // большинство методов возвращают полученое значение

  // <b>array.push(element)</b> - добавление элементов в конец массива 
  // <b>array.pop()</b> - удаление последнего элемента
  /* Методы push и unshift могут добавлять сразу по несколько элементов, указывать их через запятую. Методы push/pop выполняются быстро, а shift/unshift – медленно. Так как все элементы находятся в своих ячейках, просто удалить элемент с номером 0 недостаточно. Нужно еще и переместить остальные элементы на их новые индексы.
  */
  // <b>array.shift()</b> - удаление первого элемента массива
  // <b>array.unshift(element)</b> - добавление первого элемента в массив 

  someArray.push('My name is Eugene'); //  вернет [1,'a', 'someNoun', 6894, [0,2,4,6], 'My name is Eugene']
  someArray.pop() // вернет [1,'a', 'someNoun', 6894, [0,2,4,6]]
  someArray.shift() // вернет ['a', 'someNoun', 6894, [0,2,4,6]]
  someArray.unshift('blablabla') // вернет ['blablabla', 'a', 'someNoun', 6894, [0,2,4,6]]

  // удаление и добавление в середину массива
  // <b>array.splice(index [, deleteCount, elem1,...,elemN])</b> - Удалить deleteCount элементов, начиная с номера index, а затем вставить elem1, ..., elemN на их место. , можно с отрицательным индексом .Возвращает массив из удалённых элементов.
  var someArray = [1,'a', 'someNoun', 6894, [0,2,4,6]];
  console.log(someArray.splice(-1)); // вырежет последний элемент и вернет его
  var someArray = [1,'a', 'someNoun', 6894, [0,2,4,6]];
  console.log(someArray.splice(1,2)); // вырежет два предпоследних элемента и вернет его, останется [1, 6894, [0,2,4,6]];
  var someArray = [1,'a', 'someNoun', 6894, [0,2,4,6]];
  someArray.splice(2,2, 'My', 'name', 'is', 'Eugene');
  console.log(someArray); // вернет [1,'a', 'My', 'name', 'is', 'Eugene', [0,2,4,6]];

  // <b>array.join(разделитель)</b> - массив в строку. Не затрагивает начальный массив
  const someArray = [1, 'a', 'someNoun', 68940, '0,2,4,6'];
  someArray.join('') // вернет "1asomeNoun68940,2,4,6" 
  someArray.join() // вернет "1asomeNoun68940,2,4,6"
  someArray.join(' ') вернет "1 a someNoun 6894 0,2,4,6"
  someArray('-') // вернет "1-a-someNoun-6894-0,2,4,6"
  const array = [0, 1, 2, 3];
  const arrayChanged = array.join(', ');
  console.log(array); // [0, 1, 2, 3]
  console.log(arrayChanged); // '0, 1, 2, 3'

  // <b>array.slice(begin, end)</b> - копирование (без end - до конца), возвращает скопированное
  var items = [1,2,3,4,5,6,7,8,9],
      arrleng = items.length,
      itemsCopy = [],
      itemsCopy2 = [];
  // плохо
  for (var i = 0; i &lt; arrleng; i++) {
    itemsCopy[i] = items[i];
  }
  console.log(itemsCopy);
  // хорошо
  itemsCopy2 = items.slice();
  console.log(itemsCopy2);
  // <b>array.reverse()</b> - меняет порядок элементов
  // <b>array.concat(value1, value2, … valueN)</b> - копия массива + новые элементы. Если аргумент concat – массив, то concat добавляет элементы из него.
  var array = [1,'a', 'someNoun', 6894, [0,2,4,6]];
  console.log(array.slice(3)); // вернет [6894, [0,2,4,6]]
  array.reverse(); // вернет массив наоборот
  var newArray = array.concat(1,2);
  console.log(newArray);
  // <b>Array.from(someString)</b>  - cтатический метод array.from() позволяет создавать массивы на основании других массивов или строк. */
  var array = 'abcdefghijklmn';
  console.log(Array.from(array)); // вернет ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n"]
  const newArray = Array.from('hello');
  //массив newArray будет иметь вид ['h', 'e', 'l', 'l', 'o']
  const doubledValues = Array.from([2, 4, 6], number => number * 2);
  // в массив doubleValues будут записаны следующие данные: [4, 8, 12]

  // array.includes() - позволяет узнать, содержит ли массив заданное значение, проверяет на наличие в массиве заданного при его вызове значения.
  // Проверим, имеется ли в массиве строковой элемент waldo:
  const names = ['sophie', 'george', 'waldo', 'stephen', 'henry'];
  const includesWaldo = names.includes('waldo');   // includesWaldo получит значение true
  
  // The .<b>array.fill()</b> method fills (modifies) all the elements of an array from a start index (default zero) to an end index (default array length) with a static value. It returns the modified array.
  var array1 = [1, 2, 3, 4];
  console.log(array1.fill(0, 2, 4)); // fill with 0 from pos.2 until pos.4, expected output: [1, 2, 0, 0]
  console.log(array1.fill(5, 1)); // fill with 5 from pos.1, expected output: [1, 5, 5, 5]
  console.log(array1.fill(6)); // expected output: [6, 6, 6, 6]
  
  // The <b>array.find()</b> method returns the value of the first element in the array that satisfies the provided testing function. Otherwise undefined is returned.
  var array1 = [5, 12, 8, 130, 44];
  var found = array1.find(function(element) {
    return element > 10;
  });
  console.log(found); // expected output: 12

  //The <b>array.flat()</b> method creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.
  var arr1 = [1, 2, [3, 4]]; 
  arr1.flat(); // [1, 2, 3, 4] 
  var arr2 = [1, 2, [3, 4, [5, 6]]]; 
  arr2.flat(); // [1, 2, 3, 4, [5, 6]] 
  var arr3 = [1, 2, [3, 4, [5, 6]]]; 
  arr3.flat(2); // [1, 2, 3, 4, 5, 6]



</pre>
      </section>
      <section>
        <h4>Методы сортировки</h4>
<pre>
  // <b>sort(fn)</b> – встроенная быстрая сортировка
  var arr = [ 1, 2, 15 ];
  arr.sort();
  alert(arr); // 1, 15, 2

  /* Порядок стал 1, 15, 2 потому что по умолчанию sort сортирует, преобразуя элементы к строке, а  "2" > "15".
  Для указания своего порядка сортировки в метод arr.sort(fn) нужно передать функцию fn от двух элементов, которая умеет сравнивать их.
  Внутренний алгоритм функции сортировки умеет сортировать любые массивы – апельсинов, яблок, пользователей, и тех и других и третьих – чего угодно. Но для этого ему нужно знать, как их сравнивать. Эту роль и выполняет fn. Если эту функцию не указать, то элементы сортируются как строки. Например, укажем эту функцию явно, отсортируем элементы массива как числа: */

  var arr = [ 1, 13, 15, 8, 9, 2, 13];
  function compareNumeric(a, b) {
    return a - b;
  }
  /* или так:
  function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a &lt; b) return -1;
  }
  */
  arr.sort(compareNumeric); // вернёт [1, 2, 8, 9, 13, 13, 15]

  /* В методе sort, внутри самого интерпретатора JavaScript, реализован универсальный алгоритм сортировки. Как правило, это ««быстрая сортировка»», дополнительно оптимизированная для небольших массивов. Он решает, какие пары элементов и когда сравнивать, чтобы отсортировать побыстрее. Мы даём ему функцию – способ сравнения, дальше он вызывает её сам.
  Кстати, те значения, с которыми sort вызывает функцию сравнения, можно увидеть, если вставить в неё alert: */
  [1, -2, 15, 2, 0, 8].sort(function(a, b) {
    alert( a + " &lt;> " + b );
  });


  var myArray = [2, 3, 5, 0.5, 19, 6, 9, 11,148,11,8];
  console.log('Было: [' + myArray + ']');

  // <b>Пузырьковая сортировка / Сортировка пузырьком / Bubble Sort</b>: по очереди меняем местами сравниваемые элементы.

  function bubbleSort (arr) {
    var swaped = false; // флаг, в случае если перестановок не было, список отсортирован, значение флага изменяется (ниже) и цикл завершае работу
    var counter = 0; // УДАЛИТЬ - для обучения: счётчик для подсчёта итераций
    for (var i = 0; i &lt; arr.length - 1; i ++) { // для всех, кроме последнего элемента
      for (var j = 0; j &lt; arr.length; j ++) {
        if (arr[j] &lt; arr[j + 1]) { // или все внутри одной строчкой: [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // если элемент идующий за текущим больше его, меняем их местами, для обратной сортировки поменять знак
          var swap = arr[j];  
          arr[j] = arr[j + 1]; 
          arr[j + 1] = swap;
          swaped = true;
        }
        counter ++; // УДАЛИТЬ
      }
      if (!swaped) { break; } // для флага
    }
    console.log(counter); // УДАЛИТЬ
    return arr;
  }
  console.log('Получили от bubbleSort: [' + bubbleSort(myArray) + ']');

  // <b>Сортировка выбором / Selection Sort</b>: сравниваю каждое число с минимальным или максимальным элементом
  function selectionSort(arr) {  
    var counter = 0; // УДАЛИТЬ - для обучения: количество итераций
    for (var i = 0; i &lt; arr.length - 1; i ++){ // Выполняется для каждого элемента массива, кроме последнего.
      for (var j = i + 1; j &lt; arr.length; j ++){ // а для всех последующих элементов
        if (arr[i] > arr[j]) { // если число меньше минимального, меняем их местами, для обратной сортировки поменять знак
          var max = arr[j]; 
          arr[j] = arr[i]; 
          arr[i] = max; 
      }
      }
    }
    return arr;
  }
  console.log('Получили от selectionSort: [' + bubbleSort(myArray) + ']');
  
  // <b>Сортировка вставками / Insertion Sort</b>: перемещаю элементы пока arr[index - 1] > arr[index]
  
  function insertionSort(arr) {           
    for (var i = 1; i &lt; arr.length; i ++) { 
      var current = arr[i];  // переменная для текущего элемента, используется для обмена значениями 
      var index = i;   // индекс текущего элемента
      while (index > 0 && arr[index - 1] > current) { // перемещаем текущий элемент покуда он не станет меньше чем элемент слева от него (arr[index - 1] > current) или до тех пор пока он не станет первым в массиве (index > 0 - пока первый элемент не первый - если второй, то будет еще одна итерация)
        arr[index] = arr[index - 1];  // текущий элемент равен предыдущему элементу
        index --; // понижаем индекс для повторения цикла (продолжаем двигаться по массиву влево, если раньше сравнивали 4 и 5 элементы, то теперь будем 3 и 4)
      }
      arr[index] = current; // заканчиваем менять значения местами. Вставляем текущий элемент в отсортированную часть списка. Мы можем вставить current в положение index потому что выше мы присвоили следующему индексу значение, которое здесь было раньше. 
    }                    
    return arr;
  }
  console.log('Получили от insertionSort: [' + insertionSort(myArray) + ']');

  
  https://proglib.io/p/sort-algorithms/<br>
  // <b class="danger">Сортировка слиянием / Merge Sort</b> - там где больше 50 элементов, но ест больше оперативной памяти
  <b style="color: red; overflow-wrap: break-word;">
    https://medium.com/@alivander/
    %D1%81%D0%BE%D1%80%D1%82%D0%B8%D
    1%80%D0%BE%D0%B2%D0%BA%D0%B0
    -%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC
    -javascript-1c0b0e8ff737
  https://medium.com/@dimko1/%D0%B0%D0%BB%D0%B3%D0%BE%D1
  %80%D0%B8%D1%82%D0%BC%D1%8B
  -%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%
  80%D0%BE%D0%B2%D0%BA%D0%B8-merge-sort-9ca26ac4764a</b>
  // <b class="danger">Быстрая сортировка</b>
  <b style="color: red">https://www.youtube.com/watch?v=4s-aG6yGGLU</b>
  // <b class="danger">Shell sort</b>

  // <b class="danger">Tim sort</b>
</pre>
      </section>
    </section>


    <section class="content-section" id="functions">
      <h3>Функции</h3>
      <section>
        <h4>Общее</h4>
        <p>Чтобы не повторять один и тот же код во многих местах, придуманы функции. Функции являются основными «строительными блоками» программы. Пример объявления функции:</p>
<pre>
  var functionName = function () {
    // Действия, которые выполняет функция или «тело функции»
  };        
</pre>
        <p>Вначале идет ключевое слово function, после него имя функции, затем список параметров в скобках (в примере выше он пустой) и тело функции – код, который выполняется при её вызове.Объявленная функция доступна по имени, например:</p>
<pre>
  function showMessage() {
    alert( 'Привет всем присутствующим!' );
  }
  showMessage(); // скобки обязательны, иначе может вывести код функции             
</pre>
      </section>
      <section>
        <h4>Название функции, Function Declaration vs Function Expression</h4>
        <p>общепринятое правило именования — название функции должно содержать глагол (toShow, getAge, calcSomething, createForm, checkPermission).</p>
<pre>
  // Function Declaration
  function sum(a, b) {
    return a + b;
  }                  // главное не мешать declaration и expression !!!
  // Function Expression
  var sum = function(a, b) {
    return a + b;
  }            
</pre>
        <p>Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода (их можно вызвать до объявления). Также переменные в Function Declaration при use strict видны только внутри блока, в котором объявлены. Если нет явной причины использовать Function Expression – предпочитайте Function Declaration. Сравните по читаемости: </p>
<pre>
  // Function Expression
  var f = function() { ... }
  // Function Declaration
  function f() { ... }
</pre>
        <p>Одна функция – одно действие. Функция должна делать только то, что явно подразумевается её названием. И это должно быть одно действие. Если оно сложное и подразумевает действия, имеет смысл выделить их в отдельные функции. Например, функция проверки данных (скажем, "validate") не должна показывать сообщение об ошибке. Её действие – проверить.</p>
      </section>
      <section>
        <h4>Параметры фукнции</h4>
        <p>— значения, с помощью которых можно настраивать функции. Так мы можем узнать результат работы функции для разных случаев. С аргументами (пареметры – те же аргументы, но так они называются, когда задаются первый раз) есть один нюанс — передавать их надо в том же порядке, в котором объявлены параметры функции.</p>
<pre>
  var showTime = function (hours, minutes) {
    console.log('Текущее время: ' + hours + ':' + minutes);
  };
  showTime(3, 15);   // Выведет 'Текущее время: 3:15'
  showTime(6, 20);   // Выведет 'Текущее время: 16:20'            
</pre>
        <p class="important">Важно:</p> 
        <p>если у функции указан параметр, но аргумент не передан, то значение параметра в теле функции будет undefined — то есть ничего.</p>
      </section>
      <section>
        <h4>Локальные переменные, область видимость функций и передача функциям переменных</h4>
        <p>Функция может содержать локальные переменные, объявленные через var. Такие переменные видны только внутри функции.</p>
<pre>
  function showMessage() {
    var message = 'Привет, я - Вася!'; // локальная переменная
    alert( message );
  }
  showMessage(); // 'Привет, я - Вася!'
  alert( message ); // &lt;-- будет ошибка, т.к. переменная видна только внутри      
</pre>
        <p>Переменные, объявленные на уровне всего скрипта, называют «глобальными переменными». Обратите внимание: все манипуляции над переменными внутри функций на самом деле производятся не над самими переменными а над их копией, поэтому содержимое самих переменных в результате выполнения функций не изменяется.</p>
        <p class="important">Важно:</p>
        <p>Блоки if/else, switch, for, while, do..while не влияют на область видимости переменных.</p>
<pre>
  /* Зададим функцию, которая прибавляет к переданной переменной 10 и выводит результат на страницу */
  function plus(a){
    a=a+10;
    document.write('Вывод функции: ' + a);
  }
  var a=25;
  document.write('Значение переменной до вызова функции: '+ a);
  // Вызовем функцию передав ей в качестве аргумента переменную a
  plus(a);
  document.write('Значение переменной после вызова функции: '+ a);
</pre>
        <p>Чтобы обращаться к глобальной переменной из функции, а не ее копии используйте window.имя_переменной.</p>
<pre>
  function plus(a){
    window.a=a+10;
  }
  var a=25;
  document.write('Значение переменной до вызова функции: '+a+'<br />');
  plus(a);
  document.write('Значение переменной после вызова функции: '+a+'<br />');           
</pre>
      </section>
      <section>
        <h4>Анонимные функции</h4>
        <p>Функции, которые не содержат имени при объявлении называются анонимными. Анонимные функции в основном объявляют не для последующего их вызова из кода как обычные функции, а для передачи другим функциям в качестве параметра.</p>
<pre>
  function ask(question, yes, no) {
    if (confirm(question)) yes()
    else no();
  }
  ask(
    "Вы согласны?",
    function() { alert("Вы согласились."); },
    function() { alert("Вы отменили выполнение."); }
  );            
</pre>
        <p>Здесь функции объявлены прямо внутри вызова ask(...), даже без присвоения им имени. Функциональное выражение, которое не записывается в переменную, называют анонимной функцией. Зачем нам записывать функцию в переменную, если мы не собираемся вызывать её ещё раз? Можно просто объявить непосредственно там, где функция нужна. Такого рода код возникает естественно, он соответствует «духу» JavaScript.</p>
      </section>
      <section>
        <h4>Возвращение из функции – return blabla;</h4>
        <p>Функция может выполнить код и отдать результат операций для дальнейшей работы с этим результатом. Он подставится в то место кода, где мы вызвали функцию.</p>
<pre>
  var increaseByTwo = function (number) {
    var sum = 2 + number;
    return sum;
  };
  increaseByTwo(1); // Функция вернёт 3
  increaseByTwo(2); // Функция вернёт 4
</pre>
        <p>Когда программа доходит до строки с return, функция отдаёт результат работы и выполнение кода из тела функции останавливается, происходит выход из функции, дальнейший код функции не выполняется.</p>
        <p class="impotant">Важно:</p>
        <p>- Функция не может вернуть сразу много значений, она возвращает только один результат. <br> - Если внутри функции нет return или после return не указано, какое значение нужно вернуть, функция вернёт undefined, иными словами, ничего. Директива return может также использоваться без значения, чтобы прекратить выполнение и выйти из функции. В случае, когда функция не вернула значение или return был без аргументов, считается что она вернула undefined.</p>
        <p>... можно проверить, и если параметр не передан – присвоить ему значение «по умолчанию»:</p>
<pre>
  function showMessage(from, text) {
    if (text === undefined) {
      text = 'текст не передан';
    }
    alert( from + ": " + text );
  }
  showMessage("Маша", "Привет!"); // Маша: Привет!
  showMessage("Маша"); // Маша: текст не передан
  Или использовать оператор ||:
    function showMessage(from, text) {
    <b>text = text || 'текст не передан';</b>
    ...
  }
  </pre>
          <p>Второй способ считает, что аргумент отсутствует, если передана пустая строка, 0, или вообще любое значение, которое в логическом контексте является false.</p>
      </section>
      <section>
        <h4>Псевдомассив arguments</h4>
        <p>В JavaScript любая функция может быть вызвана с произвольным количеством аргументов:</p>
<pre>
  function go(a,b) {
    alert("a="+a+", b="+b);
  }
  go(1);     // a=1, b=undefined
  go(1,2);   // a=1, b=2
  go(1,2,3); // a=1, b=2, третий аргумент не вызовет ошибку            
</pre>
        <p>Доступ к «лишним» аргументам. Как получить значения аргументов, которых нет в списке параметров? Доступ к ним осуществляется через «псевдо-массив» arguments. Он содержит список аргументов по номерам: arguments[0], arguments[1]…, а также свойство length.</p>
<pre>
  function sayHi() {
    for (var i = 0; i &lt; arguments.length; i++) {
      alert( "Привет, " + arguments[i] );
    }
  }
  sayHi("Винни", "Пятачок"); // 'Привет, Винни', 'Привет, Пятачок'            
</pre>
        <p class="important">Важно:</p>
        <p>Аргументы отделены от локальных переменных:</p>
<pre>
  function f(x) {
    "use strict"; // для браузеров с поддержкой строгого режима
    arguments[0] = 5;
    alert( x ); // не 5, а 1! Переменная "отвязана" от arguments
  }
  f(1);            
</pre>
      </section>
      <section>
        <h4>Аргументы по умолчанию через ||.</h4>
        <p>Если функция вызвана с меньшим количеством аргументов, чем указано, то отсутствующие аргументы считаются равными undefined. Присвоить аргументу некоторое «стандартное» значение можно при помощи оператора логическое или ||.</p>
<pre>
  function showWarning(width, height, title, contents) {
    width = width || 200; // если не указана width, то width = 200
    height = height || 100; // если нет height, то height = 100
    title = title || "Предупреждение";
    //...
  }
  function showWarning(width, height, title, contents) {
    if (width === undefined) width = 200;
    if (height === undefined) height = 100;
    if (title === undefined) title = "Предупреждение";
    //...
  }            
</pre>
      </section>
      <section>
        <h4>«Именованные аргументы»</h4>
        <p>Именованные аргументы – альтернативная техника работы с аргументами, которая вообще не использует arguments. Некоторые языки программирования позволяют передать параметры как-то так: f(width=100, height=200), то есть по именам, а что не передано, тех аргументов нет. В JavaScript для этих целей используется передача аргументов в виде объекта, а в его свойствах мы передаём параметры. Получается так:</p>
<pre>
  function showWarning(options) {
    var width = options.width || 200; // по умолчанию
    var height = options.height || 100;
    var contents = options.contents || "Предупреждение";
    // ...
  }            
</pre>
        <p>Вызвать такую функцию очень легко. Достаточно передать объект аргументов, указав в нем только нужные:</p>
<pre>
  showWarning({
    contents: "Вы вызвали функцию" // и всё понятно!
  });            
</pre>
        <p>Сравним это с передачей аргументов через список:</p>
<pre>
  showWarning(null, null, "Предупреждение!");
  // мысль программиста "а что это за null, null в начале? ох, надо глядеть описание функции"
  // Именованные аргументы применяются во многих JavaScript-фреймворках.
  // Еще один бонус кроме красивой записи – возможность повторного использования объекта аргументов:
  var opts = {
    width: 400,
    height: 200,
    contents: "Текст"
  };
  showWarning(opts);
  opts.contents = "Другой текст";
  showWarning(opts); // вызвать с новым текстом, без копирования других аргументов
</pre>
        <p>Возможен и гибридный подход, при котором первый аргумент обязателен, а второй – options, который содержит всевозможные дополнительные параметры:</p>
<pre>
  function showMessage(text, options) {
    // показать сообщение text, настройки показа указаны в options
  }
</pre>
      </section>
    </section>


    <section class="content-section" id="strings">
      <h3>Строки</h3>
      <section>
        <h4>Общее</h4>
        <p>Строки создаются при помощи двойных или одинарных кавычек, различий нет между этими способами нет:</p>
<pre>
  var text = "моя строка";
  var anotherText = 'еще строка';
  var str = "012345";          
</pre>
      </section>
      <section>
        <h4>Экранирование специальных символов</h4>
        <p>Если строка в одинарных кавычках, то внутренние одинарные кавычки внутри должны быть экранированы, то есть снабжены обратным слешем \', вот так:</p>
<pre>
  var str = 'I\'m a JavaScript programmer';
  var str = "I'm a JavaScript \"programmer\" ";
  alert( str ); // I'm a JavaScript "programmer"
  var str = ' символ \\ ';
  alert( str ); // символ \

  alert( 'Привет\nМир' ); // перевод строки - выведет "Мир" на новой строке
</pre>
      </section>
      <section>
        <h4>Изменение строк</h4>
        <p>Содержимое строки в JavaScript нельзя изменять. Можно лишь создать целиком новую строку и присвоить в переменную вместо старой, например:</p>
<pre>
  var str = "строка";
  str = str[3] + str[4] + str[5];
  alert( str ); // ока            
</pre>
      </section>
      <section>
        <h4>Юникод</h4>
<pre>
  String.fromCharCode(code) // метод для получения символа по его коду:
  alert( String.fromCharCode(1072) ); // 'а' --> Возвращает символ по коду code:
  str.charCodeAt(pos) // …И метод для получения цифрового кода из символа:
  alert( "абрикос".charCodeAt(0) ); // 1072, код 'а'. Возвращает код символа на позиции pos. Отсчет позиции начинается с нуля.
</pre>
        <p>Юникод в HTML</p>
        <p>Для этого нужно написать сначала &amp;&#35;, затем код, и завершить точкой с запятой ';'. Например, символ 'а' в виде числовой ссылки: &#1072;. Если код хотят дать в 16-ричной системе счисления, то начинают с &amp;&#35;x. В юникоде есть много забавных и полезных символов, например, символ ножниц: ✂ (&#x2702;), дроби: ½ (&#xBD;) ¾ (&#xBE;) и другие. Их можно использовать вместо картинок в дизайне.</p>
      </section>
      <section>
        <h4>Методы и свойства для строк</h4>
<pre>
  // <b>Длина length</b>
  var str = "My\n"; // 3 символа. Третий - перевод строки
  alert( str.length ); // 3        
  
  // Для доступа к символу можно использовать <b>квадратные скобки</b>:
  var str = "Я - современный браузер!";
  alert( str[0] ); // "Я"
  alert( "".charAt(0) ); // пустая строка
  alert( "" [0] ); // undefined  
  //Разница между этим способом и charAt заключается в том, что если символа нет – charAt выдает пустую строку, а скобки – undefined:
  //Доступ к символам – str.charAt(позиция);
  var str = "jQuery";
  alert( str.charAt(0) ); // "j" - возращает строку из одного символа. Первый символ имеет позицию 0

  // toLowerCase() и toUpperCase() 
  alert( "Интерфейс".toUpperCase() ); // ИНТЕРФЕЙС
  // Пример ниже получает первый символ и приводит его к нижнему регистру:
  alert( "Интерфейс"[0].toLowerCase() ); // 'и'

  // <b>indexOf(подстрока[, начальная_позиция]) и lastIndexOf (ищет с конца строки)</b>
  // для поиска подстроки. Метод возвращает позицию, на которой находится подстрока или -1, если ничего не найдено. 
  var str = "Widget with id";
  console.log(str.indexOf("Widget")); // 0, т.к. "Widget" найден прямо в начале str
  console.log(str.indexOf("id")); // 1, т.к. "id" найден, начиная с позиции 1
  console.log(str.indexOf("widget")); // -1, не найдено, так как поиск учитывает регистр
  // Необязательный второй аргумент позволяет искать, начиная с указанной позиции. Например, первый раз "id" появляется на позиции 1. Чтобы найти его следующее появление – запустим поиск с позиции 2:
  var str = "Widget with id";
  console.log(str.indexOf("id", 2)) // 12, поиск начат с позиции 2

  // <b>Поиск всех вхождений</b>
  // Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Как только получаем очередную позицию – начинаем следующий поиск со следующей. Такой цикл начинает поиск с позиции 0, затем найдя подстроку на позиции foundPos, следующий поиск продолжит с позиции pos = foundPos+1, и так далее, пока что-то находит.
  var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке
  var target = "Иа"; // цель поиска
  var pos = 0;
  while (true) {
    var foundPos = str.indexOf(target, pos);
    if (foundPos == -1) break;
    alert( foundPos ); // нашли на этой позиции
    pos = foundPos + 1; // продолжить поиск со следующей
  }
  // Впрочем, тот же алгоритм можно записать и короче:
  var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке
  var target = "Иа"; // цель поиска
  var pos = -1;
  while ((pos = str.indexOf(target, pos + 1)) != -1) {
    alert(pos);
  }

  // <b>Копирование подстроки / взятие подстроки</b>: substring(start [, end]) или substr(start [, length - кол. элементов]) и <b>slice(start [, end])</b>. Ниже описан метод slice() как самый удобный в использовании
  // Возвращает часть строки от позиции start до позиции end не включая самой позиции end. Если аргумент end отсутствует, то идет до конца строки. Отрицательные значения отсчитываются от конца строки.
  alert( "testme".slice(-2) ); // "me", от 2 позиции с конца
  alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.
  var str = 'The quick red fox jumped over the lazy dog\'s back.';
  console.log(str.slice(30)); // expected output: "the lazy dog's back."
  console.log(str.slice(4, 17)); // expected output: "quick red fox"
  console.log(str.slice(-5)); // expected output: "back."
  console.log(str.slice(-11, -6)); // expected output: "dog's"
  <b>string.replace('abcd','efgh')</b>

  // <b>убрать лишние пробелы - trim()</b>, trimLeft(), trimRight()
  var string = "  Hello world";
  console.debug(string.trimLeft()); // prints "Hello world"

  <b>string.repeat(number)</b> - повторение нужного текста

  <b>array.split(s[,n])</b> - строка в массив по разделителю s, n - ограничение по количеству элементов
  var array = 'abcdefghijklmn';
  console.log(array.split('c')); // ["ab", "defghijklmn"]
  console.log(array.split('')); // вернёт ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n"]
  
  // <b>переворачиваю строку</b>
  function strRev(str) {
    return str.split('').reverse().join('');
  }
</pre>
      </section>
    </section>


    <section class="content-section" id="closures">
      <h3>Замыкания, область видимости</h3>
      <section>
        <h4>Общее</h4>
        <p>В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется «глобальный объект» (global object). В браузере этот объект явно доступен под именем window. Объект window одновременно является глобальным объектом и содержит ряд свойств и методов для работы с окном браузера. Присваивая или читая глобальную переменную, мы, фактически, работаем со свойствами window. Создать переменную можно и явным присваиванием в window:</p>
<pre>
  var a = 5; // объявление var создаёт свойство window.a
  alert( window.a ); // 5
  window.a = 6;
  alert( a ); // 6
</pre>
      </section>
      <section>
        <h4>Порядок инициализации</h4>
        <p>На первой фазе происходит инициализация, подготовка к запуску. Во время инициализации скрипт сканируется на предмет объявления функций вида Function Declaration, а затем – на предмет объявления переменных var. Каждое такое объявление добавляется в window. Функции, объявленные как Function Declaration, создаются сразу работающими, а переменные – равными undefined. Потом происходит выполнение кода. В коде ниже указано содержание глобального объекта на момент инициализации и далее последовательно по коду:</p>
<pre>
  // На момент инициализации, до выполнения кода:
  // window = { f: function, a: undefined, g: undefined }
  var a = 5;
  // window = { f: function, a: 5, g: undefined }
  function f(arg) { /*...*/ }
  // window = { f: function, a: 5, g: undefined } без изменений, f обработана ранее
  var g = function(arg) { /*...*/ };
  // window = { f: function, a: 5, g: function }
  Кстати, тот факт, что к началу выполнения кода переменные и функции уже содержатся в window, можно легко проверить, выведя их:
  alert("a" in window); // true,  т.к. есть свойство window.a
  alert(a); // равно undefined,  присваивание будет выполнено далее
  alert(f); // function ...,  готовая к выполнению функция
  alert(g); // undefined, т.к. это переменная, а не Function Declaration
  var a = 5;
  function f() { /*...*/ }
  var g = function() { /*...*/ };
</pre>
        <p>Фигурные скобки, которые используются в for, while, if, в отличие от объявлений функции, имеют «декоративный» характер.</p>
      </section>
      <section>
        <h4>Лексическое окружение</h4>
        <p>Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске. Будем называть этот объект «лексическое окружение» или просто «объект переменных». При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения. В отличие от window, объект LexicalEnvironment является внутренним, он скрыт от прямого доступа.</p>
<pre>
  // Пример
  Посмотрим пример, чтобы лучше понимать, как это работает:
  function sayHi(name) {
    var phrase = "Привет, " + name;
    alert( phrase );
  }
  sayHi('Вася');
</pre>
        <p>
          При вызове функции:
          1. До выполнения первой строчки её кода, на стадии инициализации, интерпретатор создает пустой объект LexicalEnvironment и заполняет его.
          В данном случае туда попадает аргумент name и единственная переменная phrase:
        </p>
<pre>
  function sayHi(name) {
    // LexicalEnvironment = { name: 'Вася', phrase: undefined }
    var phrase = "Привет, " + name;
    alert( phrase );
  }
  sayHi('Вася');            
</pre>
        <p>2. Функция выполняется. Во время выполнения происходит присвоение локальной переменной phrase, то есть, другими словами, присвоение свойству LexicalEnvironment.phrase нового значения:</p>
<pre>
  function sayHi(name) {
    // LexicalEnvironment = { name: 'Вася', phrase: undefined }
    var phrase = "Привет, " + name;
    // LexicalEnvironment = { name: 'Вася', phrase: 'Привет, Вася'}
    alert( phrase );
  }
  sayHi('Вася');    
</pre>
        <p>3. В конце выполнения функции объект с переменными обычно выбрасывается и память очищается. В примерах выше так и происходит.</p>
      </section>
      <section>
        <h4>Доступ ко внешним переменным</h4>
        <p>Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем LexicalEnvironment, а затем, если её нет – ищет во внешнем объекте переменных. В данном случае им является window. Такой порядок поиска возможен благодаря тому, что ссылка на внешний объект переменных хранится в специальном внутреннем свойстве функции, которое называется [[Scope]]. Это свойство закрыто от прямого доступа, но знание о нём очень важно для понимания того, как работает JavaScript.</p>
<pre>
  var userName = "Вася";
  function sayHi() {
    alert( userName ); // "Вася"
  }            
</pre>
        <p class="important">Важно:</p>
        <p>При создании функция получает скрытое свойство [[Scope]], которое ссылается на лексическое окружение, в котором она была создана. В примере выше таким окружением является window, так что создаётся свойство:</p>
<pre>
  sayHi.[[Scope]] = window
</pre>
        <p>При запуске функции её объект переменных LexicalEnvironment получает ссылку на «внешнее лексическое окружение» со значением из [[Scope]]. Если переменная не найдена в функции – она будет искаться снаружи.</p>
        <p>Всегда текущее значение. Значение переменной из внешней области берётся всегда текущее. Оно может быть уже не то, что было на момент создания функции.</p>
<pre>
  var phrase = 'Привет';
  function sayHi(name) {
    alert(phrase + ', ' + name);
  }
  sayHi('Вася');  // Привет, Вася (*)
  phrase = 'Пока';
  sayHi('Вася'); // Пока, Вася (**)            
</pre>
        <p> На момент первого запуска (*), переменная phrase имела значение 'Привет', а ко второму (**) изменила его на 'Пока'.</p>
      </section>
      <section>
        <h4>Вложенные функции</h4>
        <p>Внутри функции можно объявлять не только локальные переменные, но и другие функции:</p>
<pre>
  function sayHiBye(firstName, lastName) {
    alert( "Привет, " + getFullName() );
    alert( "Пока, " + getFullName() );
    function getFullName() {
      return firstName + " " + lastName;
    }
  }
  sayHiBye("Вася", "Пупкин"); // Привет, Вася Пупкин ; Пока, Вася Пупкин
  // Здесь, для удобства, создана вспомогательная функция getFullName().
</pre>
        <p>Вложенные функции получают [[Scope]] так же, как и глобальные. В нашем случае: getFullName.[[Scope]] = <b>объект переменных текущего запуска sayHiBye</b></p>
        <p>Заметим, что если переменная не найдена во внешнем объекте переменных, то она ищется в ещё более внешнем (через [[Scope]] внешней функции), то есть, такой пример тоже будет работать:</p>
<pre>
  var phrase = 'Привет';
  function say() {
    function go() {
      alert( phrase ); // найдёт переменную снаружи
    }
  
    go();
  }
  say();            
</pre>
      </section>
      <section>
        <h4>Возврат функции</h4>
        <p>Рассмотрим более «продвинутый» вариант, при котором внутри одной функции создаётся другая и возвращается в качестве результата.</p>
<pre>
  function makeCounter() {
    // LexicalEnvironment = { currentCount: undefined }
    var currentCount = 1;
    // LexicalEnvironment = { currentCount: 1 }
    return function() { // (**) // [[Scope]] -> LexicalEnvironment (**)
      return currentCount++;
    };
  }
  var counter = makeCounter(); // (*)
  // каждый вызов увеличивает счётчик и возвращает результат
  alert( counter() ); // 1, [[Scope]] -> {currentCount: 1}
  alert( counter() ); // 2, [[Scope]] -> {currentCount: 2}
  alert( counter() ); // 3, [[Scope]] -> {currentCount: 3}
  // создать другой счётчик, он будет независим от первого
  var counter2 = makeCounter();
  alert( counter2() ); // 1      
  
  // делал сам - постарайся объяснить код!

  // Префиксная форма:
  // function makeCounter() { 
  //   var currentCount = 1;
  //   return function() { // возвращаем функцию из функции
  //     var newNum = ++currentCount; 
  //     return newNum;
  //   };
  // }
  // var counter = makeCounter(); // записываем замыкание в переменную. 
  // console.log(counter()); // 2
  // console.log(counter()); // 3
  // console.log(counter()); // 4
  // console.log('____');
  
  // function makeCounter() { 
  //   var currentCount = 1;
  //   return function() { // возвращаем функцию из функции
  //     currentCount++; 
  //     return currentCount;
  //   };
  // }
  // var counter = makeCounter(); // записываем замыкание в переменную. 
  // console.log(counter()); // 2
  // console.log(counter()); // 3
  // console.log(counter()); // 4
  // console.log('____');
  
  function makeCounter() { 
    var currentCount = 1;
    return function() { // возвращаем функцию из функции
      return currentCount++;
    };
  }
  var counter = makeCounter(); // записываем замыкание в переменную. 
  console.log(counter()); // 1
  console.log(counter()); // 2
  console.log(counter()); // 3
  console.log('____');  
</pre>
        <p>Как видно, мы получили два независимых счётчика counter и counter2, каждый из которых незаметным снаружи образом сохраняет текущее количество вызовов. Где? Конечно, во внешней переменной currentCount, которая у каждого счётчика своя.</p>
        <p>1. В строке (*) запускается makeCounter(). При этом создаётся LexicalEnvironment для переменных текущего вызова. В функции есть одна переменная var currentCount, которая станет свойством этого объекта. Она изначально инициализуется в undefined, затем, в процессе выполнения, получит значение 1.<br>
        2. В процессе выполнения makeCounter() создаёт функцию в строке (**). При создании эта функция получает внутреннее свойство [[Scope]] со ссылкой на текущий LexicalEnvironment.<br>
        3. Далее вызов makeCounter() завершается и функция (**) возвращается и сохраняется во внешней переменной counter (*). Итоговым значением, записанным в переменную counter, является функция:
        </p>
<pre>
  function() { // [[Scope]] -> {currentCount: 1}
    return currentCount++;
  };
</pre>
      </section>
      <section>
        <h4>Свойства функции</h4>
        <p>Функция в JavaScript является объектом, поэтому можно присваивать свойства прямо к ней, вот так:</p>
<pre>
    function f() {}
    f.test = 5;
    alert( f.test );            
</pre>
        <p>Свойства функции не стоит путать с переменными и параметрами. Они совершенно никак не связаны. Переменные доступны только внутри функции, они создаются в процессе её выполнения. Это – использование функции «как функции». А свойство у функции – доступно отовсюду и всегда. Это – использование функции «как объекта».</p>
      </section>
      <section>
        <h4>Замыкания</h4>
        <p>Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны. «Понимать замыкания» в JavaScript означает понимать следующие вещи:</p>
        <p>1. Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window.</p>
        <p>2. При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана.</p>
        <p>3. При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».</p>
        <p class="important">Важно:</p>
        <p>При создании функции с использованием new Function, её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window.</p>
        <p>Улучшим счётчик, который создавали выше - перейдем на полноценный объект:</p>
<pre>
  function makeCounter() {
    var currentCount = 1;
    return { // возвратим объект вместо функции
      getNext: function() {
        return currentCount++;
      },
      set: function(value) {
        currentCount = value;
      },
      reset: function() {
        currentCount = 1;
      }
    };
  }
  var counter = makeCounter();
  alert( counter.getNext() ); // 1
  alert( counter.getNext() ); // 2
  counter.set(5);
  alert( counter.getNext() ); // 5            
</pre>
        <p>К сожалению, при переходе на объект короткий вызов пропал, вместо него теперь counter.getNext(), давайте вернём его!</p>
<pre>
  function makeCounter() {
    var currentCount = 1;
  
    // возвращаемся к функции
    function counter() {
      return currentCount++;
    }
    // ...и добавляем ей методы!
    counter.set = function(value) {
      currentCount = value;
    };
    counter.reset = function() {
      currentCount = 1;
    };
    return counter;
  }
  var counter = makeCounter();
  alert( counter() ); // 1
  alert( counter() ); // 2
  counter.set(5);
  alert( counter() ); // 5            
</pre>
      </section>
      <section>
        <h4>Задания</h4>
        <ol class="ordered-list-restored">
          <li>
            <p>Что будет, если вызов say('Вася'); стоит в самом-самом начале, в первой строке кода?</p>
<pre>
  say('Вася'); // Что выведет? Не будет ли ошибки?
  var phrase = 'Привет';
  function say(name) {
    alert( name + ", " + phrase );
  }
</pre>
            <label class="question" for="closures1">Показать ответ</label>
            <input type="checkbox" id="closures1" class="visually-hidden">
            <p>Ошибки не будет, выведет "Вася, undefined". Переменная как таковая существует, вот только на момент запуска функции она равна undefined.</p>
          </li>
          <li>
            <p>Каков будет результат выполнения этого кода? Изменится ли внешняя переменная value ? Какими будут ответы, если из строки var value = false убрать var?</p>
<pre>
  var value = 0;
  function f() {
    if (1) {
      value = true;
    } else {
      var value = false;
    }
    alert( value );
  }
  f();
</pre>
            <label class="question" for="closures2">Показать ответ</label><input type="checkbox" id="closures2" class="visually-hidden"> 
            <p>Результатом будет true, т.к. var обработается и переменная будет создана до выполнения кода. Соответственно, присвоение value=true сработает на локальной переменной, и alert выведет true. Внешняя переменная не изменится. P.S. Если var нет, то в функции переменная не будет найдена. Интерпретатор обратится за ней в window и изменит её там. Так что без var результат будет также true, но внешняя переменная изменится.</p>
          </li>
          <li>
            <p>Каков будет результат выполнения этого кода? Почему?</p>
<pre>
  function test() {
    alert( window );
    var window = 5;
    alert( window );
  }
  test();
</pre>
            <label class="question" for="closures3">Показать ответ</label><input type="checkbox" id="closures3" class="visually-hidden"> 
            <p>Результатом будет undefined, затем 5.</p>
          </li>
          <li>
            <p>Если во внутренней функции есть своя переменная с именем currentCount – можно ли в ней получить currentCount из внешней функции?</p>
<pre>
  function makeCounter() {
    var currentCount = 1;
  
    return function() {
      var currentCount;
      // можно ли здесь вывести currentCount из внешней функции (равный 1)?
    };
  }
</pre>
            <label class="question" for="closures4">Показать ответ</label><input type="checkbox" id="closures4" class="visually-hidden"> 
            <p>Нет. Локальная переменная полностью перекрывает внешнюю.</p>
          </li>
          <li>
            <p>Что выведут эти вызовы, если переменная currentCount находится вне makeCounter?</p>
<pre>
  var currentCount = 1;
  function makeCounter() {
    return function() {
      return currentCount++;
    };
  }
  var counter = makeCounter();
  var counter2 = makeCounter();
  
  alert( counter() ); // ?
  alert( counter() ); // ?
  alert( counter2() ); // ?
  alert( counter2() ); // ?
</pre>
            <label class="question" for="closures5">Показать ответ</label><input type="checkbox" id="closures5" class="visually-hidden">
            <p>Выведут 1,2,3,4. Здесь внутренняя функция будет искать – и находить currentCount каждый раз в самом внешнем объекте переменных: глобальном объекте window. В результате все счётчики будут разделять единое, глобальное текущее значение.</p>
          </li>
          <li>
            <p>Напишите функцию sum, которая работает так: sum(a)(b) = a+b. Да, именно так, через двойные скобки (это не опечатка). Например:</p>
<pre>
  // sum(1)(2) = 3
  // sum(5)(-1) = 4                
</pre>
            <label class="question" for="closures6">Показать ответ</label><input type="checkbox" id="closures6" class="visually-hidden">
<pre>
  function sum(a) {
    return function(b) {
      return a + b
    }
  }
  var some = sum(5)(-2);
  console.log(some);    
</pre>
          </li>
          <li>
            <p>
                <img src="images/closures__1.png" alt="closures__1">
            </p>  
<pre>
  // код, от которого можно отталкиваться
  // function makeBuffer() { /* ваш код */ }
  // var buffer = makeBuffer();
  // // добавить значения к буферу
  // buffer('Замыкания');
  // buffer(' Использовать');
  // buffer(' Нужно!');
  // // получить текущее значение
  // alert( buffer() ); // Замыкания Использовать Нужно!         
</pre>
            <label class="question" for="closures7">Показать ответ</label><input type="checkbox" id="closures7" class="visually-hidden">  
<pre>
  // 1
  function makeBuffer() {
    var value = '';
    return function(newInfo) {
            if (newInfo || newInfo === 0) {
              value += newInfo;
              return value;
            } 
            return value;
          }
  }
  var buffer = makeBuffer();
  buffer('Замыкания');
  console.log(buffer());
  buffer(' Использовать');
  buffer(' Нужно!');
  console.log(buffer()); 
  // Буфер должен преобразовывать все данные к строковому типу:
  var buffer2 = makeBuffer();
  buffer2(0);
  buffer2(1);
  buffer2(0);
  console.log(buffer2()); // '010'                

  // 2
  function makeBuffer() { 
    var stringBuffer = '';
    return function addInfo() {
             if (arguments.length > 0) {
               for (var i = 0; i &lt; arguments.length; i ++) {
                 stringBuffer += arguments[i] + ' ';
               }
             }
             return stringBuffer;
           }
  }
  
  var buffer = makeBuffer(); // сохраняем результат внешней функции - передаёйтся вся функция
  console.log(buffer); 
  // добавить значения к буферу
  buffer('Замыкания');  // вызываем результат внешней функции с параметром - она же вложенная функция
  buffer('Использовать ОЧЕНЬ');
  buffer('Нужно!');
  // получить текущее значение
  console.log( buffer() ); // Замыкания Использовать Нужно!   
</pre>
          </li>
          <li>
            <p>Добавьте буферу из решения задачи №7 метод buffer.clear(), который будет очищать текущее содержимое буфера:</p>
            <label class="question" for="closures8">Показать ответ</label><input type="checkbox" id="closures8" class="visually-hidden">
<pre>
    function makeBuffer() { 
      var stringBuffer = '';
      function addInfo() {
        if (arguments.length !== 0) {
          for (var i = 0; i &lt; arguments.length; i ++) {
            stringBuffer += arguments[i] + ' ';
          }
        }
        return stringBuffer; // возвращаю буфер (если есть аргументы - добавляю их)
      }
      addInfo.clear = function() {
        return stringBuffer = ''; // свойство функции addInfo для очистки себя -- или без return?
      }
      return addInfo;
    }
    
    var buffer = makeBuffer(); // сохраняем результат внешней функции - передаёйтся вся функция
    console.log(buffer); 
    // добавить значения к буферу
    buffer('Замыкания');  // вызываем результат внешней функции с параметром - она же вложенная функция
    buffer('Использовать ОЧЕНЬ');
    buffer.clear();
    buffer('Нужно!');
    // получить текущее значение
    console.log( buffer() ); // Замыкания Использовать Нужно!            
</pre>
          </li>
          <li>
            <p>
              <img src="images/closures__2.png" alt="closures__2">
            </p>
<pre>
  // код, которым можно проверить правильность ответа
  users.sort(byField('name'));
  users.forEach(function(user) {
    console.log(user.name);
  }); // Вася, Маша, Петя

  users.sort(byField('age'));
  users.forEach(function(user) {
    console.log(user.age);
  }); // Маша, Вася, Петя
</pre>
            <label class="question" for="closures9">Показать ответ</label><input type="checkbox" id="closures9" class="visually-hidden">
<pre>
  function byField(fieldName) {
    return function(a, b) { // передаю сюда функцию с a и b, потому что sort принимает функцию с двумя параменрами
      return a[fieldName] > b[fieldName] ? 1 : -1;
    }
  }
  users.sort(byField('name'));
  users.forEach(function(user) {
    console.log(user.name);
  }); // Вася, Маша, Петя
  console.log('**');
  users.sort(byField('age'));
  users.forEach(function(user) {
    console.log(user.age);
  }); // Вася, Маша, Петя
  console.log('____');
</pre>
          </li>
          <li>
            <p>
              <img src="images/closures__3.png" aLT="closures__3">
            </p>
            <label class="question" for="closures10">Показать ответ</label><input type="checkbox" id="closures10" class="visually-hidden">
<pre>
  function filter(arraySample, functionSample) {
    var newArray = []; // создаю новый массив, который буду формировать
    arraySample.forEach(function(item) { // проверяю каждое значения массива, который дан изначально
      if (functionSample(item)) { // если для элемента функция фозвращает правду, то добавляю элемент в новый массив
        newArray.push(item);
      }
    });
    return newArray; // возврвщаю массив
  }
  
  function inBetween(a,b) { // функция - параменты это крайние значения
    return function(item) { // другая функция для переменной с элементом
      return a &lt; = item && item >= b;
    };
  }
  function inArray(arr) {
    return function(item) {
      return arr.indexOf(item) != -1;
    };
  }
  
  var arr = [1, 2, 3, 4, 5, 6, 7];
  // передаю в функцию массив с числами от 1 до 7 и функцию, которая возвращает правду для выполненого условия
  console.log(filter(arr, function(a) { return a % 2 == 0 })); // [2,4,6]
  console.log( filter(arr, inBetween(3, 6)) ); // [3,4,5,6]
  console.log( filter(arr, inArray([1, 2, 10])) ); // [1,2]
  console.log('__');                
</pre>
          </li>
          <li>
            <p>Армия функций</p>
          </li>
        </ol>
      </section>
    </section>

    <section class="content-section" id="objects">
      <h3>Объекты</h3>
      <section>
        <h4>Общее</h4>
        <p>Объект — тип данных, который хранит в себе информацию в виде пар «ключ-значение». Если массив — нумерованный список, где каждый элемент имеет свой порядковый номер, то объект — список, в котором каждый элемент сопоставлен со своим ключом и порядок совсем неважен.</p>
        <p>Создание объекта</p>
<pre>
  var cat = {};
  // Так создаётся объект с именем cat
</pre>
        <p>Добавление свойств</p>
        <p>Пары «ключ-значение», которые содержит в себе объект, называются свойствами или атрибутами.<br>
        - Ключ обособляется от значения двоеточием.<br>
        - Пары «ключ-значение» отделяются друг от друга запятыми.<br>
        - Значениями могут быть данные любого типа (число, строка, массив и так далее).<br>
        Выглядят они так:</p>
<pre>
  var cat = {
    name: 'Кекс',
    // Добавили новое свойство, где name — ключ, 'Кекс' — значение
    age: 5
    // Новое свойство. Ключ — age, значение — 5
  };  
  var user = {
    name: "Таня",
    age: 25,
    size: {
      top: 90,
      middle: 60,
      bottom: 90
    }
  }
  alert(user.name) // "Таня"
  alert(user.size.top) // 90          
</pre>
      </section>
      <section>
        <h4>Читаем из объекта</h4>
        <p>Чтобы получить значение свойства, к нему надо обратиться через точку объект.ключ или через скобки объект[‘ключ’]. Если свойства нет,  вы получите undefined, то есть ничего. На практике это выглядит так:</p>
<pre>
  var cat = {
    name: 'Кекс',
    age: 5
  };
  console.log(cat.name); // Выведет в консоль 'Кекс'
  console.log(cat.age); // Выведет в консоль 5
  console.log(cat.color); // Выведет undefined, такого ключа в объекте нет            
</pre>
        <p>Скобочная нотация намного гибче точечной. Например, вы можете прочитать из объекта свойство, название которого записано в переменную. В качестве ключей в объекте можно использовать любые строки, даже строки с пробелами. С точечной нотацией такие свойства прочитать не получится, а со скобочной — без проблем.</p>
<pre>
  var name = 'Кекс';
  var catsFavoriteFood = { Кекс: 'рыба' };
  console.log(catsFavoriteFood.name);
  // Выведет в консоль undefined
  console.log(catsFavoriteFood[name]);
  // Выведет в консоль 'рыба'
  var cat = { 'favorite food': 'Сметана' };
  console.log(cat.favorite food);
  // Вызовет ошибку
  console.log(cat['favorite food']);
  // Отработает нормально    
</pre>
<p>
  Доступ через точку используется, если мы на этапе написания программы уже знаем название свойства. А если оно будет определено по ходу выполнения, например, введено посетителем и записано в переменную, то единственный выбор – квадратные скобки.
</p>
      </section>
      <section>
        <h4>Добавление и удаление свойств</h4>
<pre>
  // obj['param125'] = '123'; или просто переменная
  // obj.param125 = '123'; или просто переменная

  delete person.age;
</pre>
      </section>
      <section>
        <h4>Есть ли свойство? и переопределение свойств</h4>
        <p>- <b>оператор: "in"</b>. Его синтаксис: "prop" in obj, причем имя свойства – в виде строки, например:</p>
<pre>
  if ("name" in person) {
    alert( "Свойство name существует!" );
  }            
</pre>
        <p>Сравнивает значения с undefined. Дело в том, что в JavaScript можно обратиться к любому свойству объекта, даже если его нет. Ошибки не будет. Но если свойство не существует, то вернется специальное значение undefined. Внимание: не забывать, что значение свойства теоретически может быть и undefined.</p>
<pre>
  var person = {
    name: "Василий"
  };
  alert( person.lalala === undefined ); // true, свойства нет
  alert( person.name === undefined ); // false, свойство есть.
  
  if (obj.prop !== undefined).            
</pre>
        <p>- <b>elem.hasOwnProperty()</b></p>
<pre>
  const object1 = new Object();
  object1.property1 = 42;
  console.log(object1.hasOwnProperty('property1'));
  // expected output: true            
</pre>
        <p>Переопределение свойств объекта. Свойства объектов можно не только читать, но и переопределять, как и обычные переменные.</p>
<pre>
  var cat = {
    name: 'Кекс',
    age: 5
  };
  cat.age++; // Увеличили возраст кота на 1
  console.log(cat.age) // Выведет в консоль 6
  cat.name = 'Рокки'; // Заменили снаружи значение свойства name
  console.log(cat.name); // Выведет в консоль 'Рокки'
</pre>
      </section>
      <section>
        <h4>Передаём объект по ссылке – при копировании – ссылка на объект, копия объекта не создаётся</h4>
<pre>
  var firstCat = {
    name: 'Кекс',
    age: 5
  };
  
  var secondCat = firstCat;
  console.log(secondCat);
  // Выведет {"name":"Кекс","age":5}
  
  firstCat.name = 'Снежок';
  console.log(secondCat);
  // Выведет {"name":"Снежок","age":5}            
</pre>
        <p>Мы же не трогали второй объект secondCat, но он изменился вместе с первым объектом firstCat. Почему так? В JS объект всегда один, в памяти не создаётся новое место под копию объекта. Каждая переменная содержит не новую отдельную сущность, а ссылку на один-единственный объект. Поэтому когда мы меняем что-то в объекте через одну из переменных, в которой содержится ссылка на него, изменения видны во всех других переменных, будь их хоть двадцать или сорок. Это важная особенность объектов, которую надо запомнить. Она так и называется — передача объектов по ссылке.</p>
      </section>
      <section>
        <h4>Клонирование объектов</h4>
        <p>Иногда, на практике – очень редко, нужно скопировать объект целиком, создать именно полную независимую копию, «клон» объекта.  Для этого нужно пройти по объекту, достать данные и скопировать на уровне примитивов:</p>
<pre>
  var user = {
    name: "Вася",
    age: 30
  };
  var clone = {}; // новый пустой объект
  // скопируем в него все свойства user
  for (var key in user) {
    clone[key] = user[key];
  }
  // теперь clone - полностью независимая копия
  clone.name = "Петя"; // поменяли данные в clone
  alert( user.name ); // по-прежнему "Вася"            
</pre>
        <p>
          В этом коде каждое свойство объекта user копируется в clone. Если предположить, что они примитивны, то каждое скопируется по значению и мы как раз получим полный клон. Если же свойства объектов, в свою очередь, могут хранить ссылки на другие объекты, то нужно обойти такие подобъекты и тоже склонировать их. Это называют «глубоким» клонированием.
        </p>
      </section>
      <section>
        <h4>Пример кода: игра в кости</h4>
<pre>
  // 1.
  // пишем объекты с правилами и игроками
  var gameRules = { 
    diceNumber: 1,
    maxAttempts: 1
  };
  var firstCat = {
    name: 'Кекс',
    points: 0
  };
  var secondCat = {
    name: 'Рудольф',
    points: 0
  };
  var thirdCat = {
    name: 'Рокки',
    points: 0
  };
  
  // 2.
  // формируем массив с игроками
  var cats = [firstCat, secondCat, thirdCat]; 
  
  // 3.
  // функция для подсчёта очков (аргументы: правила, игроки)
  // цикл1 (для попыток): начинаем с первой попытки, число попыток прописано в правилах, цикл2 (для игроков): результат броска записываем в переменную, потом увеличиваем количество очков игрока на эту переменную
  // возвращаем измененный массив с игроками (с перезаписанным количеством очков)
  var runGame = function (rules, players) { 
    for (var currentAttempt = 1; currentAttempt &lt; = rules.maxAttempts; currentAttempt ++) {
      for (var i = 0; i &lt;  players.length; i++) {
        var throwResult = keks.throwDice(rules.diceNumber, rules.diceNumber * 6);
        players[i].points += throwResult;
        console.log(players[i].name + ' выбросил ' + players[i].points);
      }
    }
    return players;
  };
  
  // 4.
  // функция для определения подебителей
  // создаём пустой массив winners для победителей 
  // представляем, что первый игрок выкинул больше всех и записываем его объект в переменную max
  // цикл (для записи победителей): для удобства записываем текущего игрока в переменную currentPlayer, если количество очков какого-либо игрока > max.points, то в max записываем значение currentPlayer, стирая предыдущее. Если очки currentPlayer === очкам max, то добавляем в массив winners нового победителя (currentPlayer). 
  // возвращаем массив winners со значениями, которые внесли в этой функции
  var getWinners = function (players) {
    var winners = [];
    var max = players[0];
  
    for (var i = 0; i &lt; players.length; i++) {
      var currentPlayer = players[i];
      if (currentPlayer.points > max.points) {
        max = currentPlayer;
        winners = [max];
      } else if (currentPlayer.points === max.points) {
        winners.push(currentPlayer);
      }
    }
  
    return winners;
  };
  
  // 5.
  // функция для вывода победителей
  // проверка "если победили все" (если длинна массивов с игроками и победителями одинаковая): выводим строку с текстом в консоль и заканчиваем выполнение функции (return)
  // для тех случаев, когда победили не все создаем "шапку сообщения" с текстом "победил" и записываем её в переменную
  // если победителей больше одного, меняем "победил" на "победили"
  // цикл (перебираем победителей): ко всем элементам после первого добавляем запятую. У последнего элемента запятой не будет, так как код с добавлением запятой стоит перед добавлением имени победителя в выводимое сообщение
  var printWinners = function (players, winners) {
    if (players.length === winners.length) {
      console.log('Все коты как на подбор!');
      return;
    }
  
    var message = 'Победил ';
    if (winners.length > 1) {
      message = 'Победили '
    }
    for (var i = 0; i &lt; winners.length; i++) {
      if (i >= 1) {
        message += ', '  
      }
      message += winners[i].name;
    }
  
    message += ' с количеством очков: ' + winners[0].points;
  
    console.log(message);
  };
  
  // 6.
  // посчитали очки, переписали cats: вызываем функцию для подсчёта очков (которая перезаписывает значение очков в каждом объекте), подставляем в неё значения объекта с правилами и массив с именами котов. Здесь же перезаписываем значение массива cats на значение, которое возвращаем из этой функции
  // формируем массив победителей со значений cats: вызываем функцию для определения победителей, подставляем массив cats. Здесь же заносим массив с победителями в переменную tops
  // выводим победителей: вызываем функцию для вывода победителей, подставляем массив cats и массив  
  cats = runGame(gameRules, cats); // 
  var tops = getWinners(cats); // 
  printWinners(cats, tops); //
</pre>
      </section>
      <section>
        <h4>Функции в объектах – методы объектов</h4>
        <p>В объектах могут храниться любые типы данных, в том числе и функции. Такие свойства-функции называются методами объектов. Они вызываются так же, как и любые другие функции, через круглые скобки, а обращаемся мы к методам, как и к свойствам объекта. В итоге вызов метода записывается так: объект.метод().</p>
<pre>
  var cat = {
    name: 'Кекс',
    color: 'рыжий',
    age: 5,
    getGreeting: function() {
      return 'Мяу, привет!';
    }
  };
  console.log(cat.getGreeting()); // Выведет 'Мяу, привет!'            
</pre>
      </section>
      <section>
        <h4>Словари (мапы)  - асоциативные массивы</h4>
        <p>Раз методы это те же функции, почему мы вообще записываем их в объект, а не используем привычные внешние функции? Методы используются для работы с объектами. Они читают свойства, переписывают их и возвращают. Да, можно создать внешнюю функцию, передавать ей объект и обрабатывать внутри этой функции. Но намного удобней держать в объекте всё, что относится именно к этому объекту. Например, мы храним технические характеристики внутри объекта компьютера, нам нужно возвращать строку с данными и высчитывать цену. Эти две задачи связаны именно с объектом компьютера, поэтому мы будем записывать эти функции в объект.</p>
        <p>В некоторых ситуациях блоки с условиями можно сократить с помощью объектов. Давайте разбираться, как это сделать. Рассмотрим на примере.</p>
<pre>
  var printFavoriteFood = function (name) {
    var message = 'Моя любимая еда — ';
    if (name === 'Кекс') {
      message += 'рыба';
    } else if (name === 'Рудольф') {
      message += 'котлета';
    } else if (name === 'Снежок') {
      message += 'сметана';
    }
    return message;
  };
  console.log(printFavoriteFood('Снежок')); // Выведет 'Моя любимая еда — сметана 
</pre>
        <p>Обратите внимание, что каждому коту, а точнее его имени, соответствует определённая еда. При этом порядок котов совсем неважен. Можно ли записать вкусовые предпочтения котов в объект? Давайте попробуем.</p>
<pre>
  var catsFavoriteFood = {
    Кекс: 'рыба',
    Рудольф: 'котлета',
    Снежок: 'сметана'
  };            
</pre>
        <p>Можно ли теперь использовать данные в объекте catsFavoriteFood так, чтобы совсем избавиться от условий в теле функции printFavoriteFood? Можно! Перед нами обычный объект со свойствами и их значениями. Значит, мы можем обратиться к свойству объекта и подставить в выражение строку, которая в нём содержится.</p>
<pre>
  var catsFavoriteFood = {
    Кекс: 'рыба',
    Рудольф: 'котлета',
    Снежок: 'сметана'
  };
  var printFavoriteFood = function (name) {
    return 'Моя любимая еда — ' + catsFavoriteFood[name];
  };
  console.log(printFavoriteFood('Снежок')); // Выведет 'Моя любимая еда — сметана'          
</pre>
        <p>Код работает, как и прежде, зато насколько сократилась наша программа! Мы записали в объект не характеристику вида name: 'Кекс', а соотношение имени кота и лакомства, которое по вкусу именно ему. Такие объекты называют словарями, мапами или ассоциативными массивами. Они очень удобны в использовании и позволяют писать код чище и проще.</p>
      </section>
      <section>
        <h4>this</h4>
        <p>ключевое слово this указывает на конкретный объект, а именно на тот объект, на котором была вызвана функция (метод). Использовать this просто, достаточно заменить название объекта на ключевое слово в обращении к свойству. Вместо объект.свойство используем this.свойство. Оно указывает на текущий объект и называется контекстом вызова.</p>
<pre>
  var cat = {
    name: 'Рудольф',
    introduce: function () {
      console.log('Мяу! Я кот ' + this.name + '!');
    }
  };
  cat.introduce(); // Выведет 'Мяу! Я кот Рудольф!'            
</pre>
<p>Объект, на который указывает this называется контекстом вызова. Важная деталь: пока функция не вызвана, this не содержит никакого значения, контекст появляется только в момент вызова функции.  Ключевое слово this приносит много пользы разработчикам. О других преимуществах и особенностях this вы узнаете позже, в дальнейших курсах, а пока заменим обращение к свойствам внутри объекта computer.</p>
      </section>
      <section>
        <h4>Пример кода: Интернет-магазин компьютеров</h4>
<pre>
  // 1.
  // словарь с процессорами
  // словарь с дисплеями
  // словарь с памятью
  var processorPrice = {
    'i5': 5000,
    'i7': 10000
  };
  var displayPrice = {
    13: 5000,
    15: 10000
  };
  var memoryPrice = {
    8: 3000,
    16: 4000
  };
  
  // 2.
  // функция для определения цены компьютера 
      // объект с компьютером
          // функция-описание: называем характеристики компьютера
          // функция-калькулятор: считаем цену компьютера
      // возвращаем объект
  //
  var buildComputer = function (memory, display, processor) {
    var customComputer = {
      basicPrice: 5000,
      processor: processor,
      display: display,
      memory: memory,
      getDescription: function () {
        return 'компьютер с процессором ' + this.processor + ', диагональю ' + this.display + ', оперативной памятью ' + this.memory;
      },
      getPrice: function () {
        return this.basicPrice + processorPrice[this.processor] + displayPrice[this.display] + memoryPrice[this.memory];
      }
    };
    return customComputer;
  };
  
  // 3.
  // переменная1 = функция(уникальные характеристики компьютера)
  // выводим в консоль: функция-описание от переменной1 (функция объекта, который находится в функции) и функция-калькулятор от переменной1
  // переменаня2 = функция(уникальыне характеристики компьютера)
  // выводим в консоль: функция-описание от переменной2 (функция объекта, который находится в функции) и функция-калькулятор от переменной2
  //
  var myComputer = buildComputer(8, 13, 'i7');
  console.log('В корзине ' + myComputer.getDescription() + ' стоимостью ' + myComputer.getPrice());
  var anotherComputer = buildComputer(16, 15, 'i5');
  console.log('В корзине ' +  anotherComputer.getDescription() + ' стоимостью ' + anotherComputer.getPrice());            
</pre>
      </section>
      <section>
        <h4>Строительство дома</h4>
<pre>
  // словарь ассоциаций
  var materialPrice = {  
    'wood': 1000,
    'stone': 1500,
    'brick': 2000
  };
  // пишем функцию(параметры соответствуют значениям "ключей" у объекта)
  calculateSample = function(rooms, floors, material, coefficient) {
  
  var house = {
    rooms: rooms,
    floors: floors,
    material: material,
    coefficient: coefficient,
  // расчитываем площадь, используя this
    calculateSquare: function() {
      var area = this.rooms * this.floors * this.coefficient;
      return area;  
    },
  // расчитываем стоимость, используя this
    calculatePrice: function() {
      var cost = this.calculateSquare() * materialPrice[this.material];
      return cost;
    }
  };
  // возвращаем изменённый объект house (новые значение будут только у вызова функции, где значения rooms, floors, material, coefficient будут заменяться новыми)
    return house;
  }
  
  var newHouse = calculateSample(6, 8, 'brick', 10);
  console.log('Дом с площадью '+ newHouse.calculateSquare() + ' м2 (' + newHouse.rooms + ' комнат на этаже' + ', ' + newHouse.floors + ' этажей' + ', средняя площадь комнаты - ' + newHouse.coefficient + ' м2, сделан из материала ' + newHouse.material + ') ' + 'обойдётся тебе в ' + newHouse.calculatePrice() + ' тыс. долларов');            
</pre>
      </section>
      <section>
        <h4>Методы объектов</h4>
<pre>
  // Получение <b>первого ключа и его значения</b>:
  var firstKeyName = Object.keys(someObject)[0]
  var firstKeyValue = someObject[Object.keys(salaries)[0]];

  // <b>for...in</b> -- проходит по ключам объекта
    var someObj= {
    name: 'Eugene', 
    age: 23, 
    IQ: 90, sex: 'male'
  };
  for (var key in someObj) {
    console.log('Ключ: ' + key + ', значение: ' + someObj[key] );
  }
  console.log('_____');
  // Как уже говорилось, если имя свойства хранится в переменной, то обратиться к нему можно только так, не через точку.

  // Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые – сортируются (в современных браузерах). Если нужно, чтобы порядок перебора числовых ключей соответствовал их объявлению в объекте, то используют трюк: числовые ключи заменяют на похожие, но содержащие не только цифры. Например, добавляют в начало +, как описано в примере выше, а потом, в процессе обработки, преобразуют такие ключи в числа.
  var codes = {
    "+7": "Россия",
    "+38": "Украина",
    "+1": "США"
  };
  for (var code in codes) {
    var value = codes[code];
    code = +code; // ..если нам нужно именно число, преобразуем: "+7" -> 7
    alert( code + ": " + value ); // 7, 38, 1 во всех браузерах
  }

  // считать <b>количество ключей в объекте</b>: - через counter в цикле
  var someObj = {
    name: 'Eugene',
    age: 23,
    sex: 'male'
  }
  var counter = 0;
  for (var key in someObj) {
    counter ++;
  }
  console.log(counter);
  // или так:
  var size = <b>Object.keys(myObj).length</b>;

  // <b>Вернуть массив ключе</b>й объекта - Object.keys(someObject)
  const icecreamColors = {
    chocolate: 'brown',
    vanilla: 'white',
    strawberry: 'red',
  }
  const types = Object.keys(icecreamColors);
  //вот как будет выглядеть массив types: ["chocolate", "vanilla", "strawberry"]

  // Вернуть <b>массив значений объекта</b> - Object.values(someObject)
  const icecreamColors = {
      chocolate: 'brown',
      vanilla: 'white',
      strawberry: 'red',
  }
  const colors = Object.values(icecreamColors);
  // массив colors будет иметь вид ["brown", "white", "red"]

  // массив из объекта - Object.entries(someObject)
  const weather = {
    rain: 0,
    temperature: 24,
    humidity: 33,
  }
  const entries = Object.entries(weather);
  // в массив entries попадут следующие данные
  // [['rain', 0], ['temperature', 24], ['humidity', 33]]

  // Клонировать объект
  var user = {
    name: "Вася",
    age: 30
  };
  var clone = {}; // новый пустой объект
  // скопируем в него все свойства user
  for (var key in user) {
    clone[key] = user[key];
  }
  // или так:
  function copy() {
    var dst = arguments[0];
    for (var i = 1; i &lt; arguments.length; i++) {
      var arg = arguments[i];
      for (var key in arg) {
        dst[key] = arg[key];
      }
    }
    return dst;
  }
  
</pre>
      </section>
    </section>

    <section class="content-section" id="JS-n-browser">
      <h3>JS, HTML и браузер</h3>
      <section>
        <h4>Общее</h4>
        <p>Подключение скриптов</p>
        <ul>
          <li>Если указан атрибут src, то содержимое тега игнорируется. В одном теге SCRIPT нельзя одновременно подключить внешний скрипт и указать код. </li>
          <li>Если браузер видит тег ''script''', то он по стандарту обязан сначала выполнить его, а потом показать оставшуюся часть страницы. Если скрипт – внешний, то пока браузер не выполнит его, он не покажет часть страницы под ним.</li>
          <li>существуют случаи, когда не нужно ждать загрузки всей страницы для загрузки скрипта, для таких ситуаций используют атрибут async / defer</li>
          <li>Async - при обнаружении ''script async src="..."'' браузер не останавливает обработку страницы, а работает дальше. Скрипт выполнится, когда будет загружен.</li>
          <li>Defer (выполнение – после загрузки страницы) - Похоже, но относительный порядок скриптов с defer будет сохранён. Второе отличие – скрипт с defer сработает, когда весь HTML-документ будет обработан браузером.</li>
        </ul>
<pre>
// Остановить скрипт: 
  function pow(x, n) {
    ...
    debugger; // &lt; -- отладчик остановится тут
    ...
  }
</pre>
        <p>
          DOM - Document object Model<br>
          BOM - Browser Object Model<br>
          HTTP - работа с сетью
          ''canvas''
        </p>
      </section>
      <section>
        <h4>alert, prompt, confirm</h4>
        <p>Влиять на внешний вид нельзя. Окно сообщения, которое выводится, является модальным окном. Слово «модальное» означает, что посетитель не может взаимодействовать со страницей, нажимать другие кнопки и т.п., пока не разберётся с окном.</p>
<pre>
  // alert(сообщение); выводит сообщение и приостанавливает выполнение скрипта, пока пользователь не нажмёт «ОК».
  alert("Привет");

  prompt result = prompt(title, default);
  //Функция выводит модальное окно с заголовком title, полем для ввода текста, заполненным строкой по умолчанию default и кнопками OK/CANCEL.
  var years = prompt('Сколько вам лет?', 100);
  alert('Вам ' + years + ' лет!');
  Рекоммендуется всегда указывать второй аргумент:
  var test = prompt("Тест", ''); // &lt; -- так лучше

  confirm result = confirm(question);
  // confirm выводит окно с вопросом question с двумя кнопками: OK и CANCEL. Результатом будет true при нажатии OK и false – при CANCEL(Esc):
  var isAdmin = confirm("Вы - администратор?");
  alert( isAdmin );
</pre>
      </section>
      <section>
        <h4>Поиск DOM элемента</h4>
        <p>JavaScript особым образом воспринимает разметку: элементы здесь не строки, которые мы пишем в HTML-файлах, а объекты. При этом каждый объект связан с другими такими же объектами и знает о своём родителе, соседних объектах-элементах, вложенных объектах. В итоге получается древовидная структура, которая называется DOM (Document Object Model или объектная модель документа). В каждом DOM-дереве есть корневой объект, из которого «растут» другие объекты. Он называется document. Этот глобальный объект доступен во всех программах, которые работают в браузере. Проще говоря, document — страница, которая содержит все элементы разметки (объекты). С помощью document разработчики могут найти любой объект на странице, а потом изменить его. Для этого у объекта document есть специальные методы поиска.</p>
<pre>
  // <b>querySelector</b> - принимает любые селекторы и всевдоклассы
  var list = document.querySelector('ul'); // Поиск элемента по тегу
  var lastProduct = document.querySelector('li:last-child'); // Поиск последнего элемента из списка
  var price = document.querySelector('.price'); // Поиск элемента по классу
  var thirdProduct = document.querySelector('.product:nth-child(3)'); // Поиск третьего элемента из списка товаров

  // <b>querySelecorAll</b> - возвращает не первый найденный элемент, а список (коллекцию / пседомассив) всех элементов, подходящих по селектору.
  var updateCards = function(products) {
    var elements = document.querySelectorAll('.product');
    console.log(elements);
  }
  // еще пример
  Следующий запрос получает все элементы LI, которые являются последними потомками в UL:
  ul
    li -- Этот -- li
    li -- тест -- li
  ul
  ul
    li -- полностью -- li
    li -- пройден -- li
  ul
  // JS
    var elements = document.querySelectorAll('ul > li:last-child');
    for (var i = 0; i &lt; elements.length; i++) {
      alert( elements[i].innerHTML ); // "тест", "пройден"
    }

  // <b>getElementsByTagName</b> - Метод elem.getElementsByTagName(tag) ищет все элементы с заданным тегом tag внутри элемента elem и возвращает их в виде списка.
  var elements = document.getElementsByTagName('div');
  // document.getElementsByName -- по атрибуту name

  // <b>document.getElementById</b> - только для document.
  var elem = document.getElementById('content');

  // <b>getElementsByClassName</b> - Вызов elem.getElementsByClassName(className) возвращает коллекцию элементов с классом className. Находит элемент и в том случае, если у него несколько классов, а искомый – один из них.
  var articles = document.getElementsByClassName('article');
  alert( articles.length ); 

  // <b>elem.closest(css)</b>
  // Метод elem.closest(css) ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css. Сам элемент тоже включается в поиск. Иначе говоря, метод closest бежит от текущего элемента вверх по цепочке родителей и проверяет, подходит ли элемент под указанный CSS-селектор. Если подходит – останавливается и возвращает его. 
</pre>
      </section>
      <section>
        <h4>Возврат дочерних элементов</h4>
<pre>
  // <b>DOM-элемент.children</b> → возвращает коллекцию дочерних, то есть вложенных, DOM-элементов. 
  var cardList = document.querySelector('.products');
  console.log(cardList.children);
  var elem = document.body.children[0];
  // передав <b>звездочку '*' вместо тега</b>:
  elem.getElementsByTagName('*');
</pre>
      </section>
      <section>
        <h4>Работа с классами и тегами</h4>
        <p>Среди свойств DOM-элементов — объект classList. Он содержит методы для управления классами DOM-элемента. Обратите внимание, что точку перед названием класса ставить не нужно:</p>
<pre>
  // <b>Добавляем класс</b>
  product.classList.add('product--sale');
  // <b>Удаляем класс</b>
  popup.classList.remove('popup--open');
  // <b>Переключаем класс</b>
  popup.classList.toggle('popup--open');
  // <b>Есть ли класс?</b>
  elem.classList.contains("class") // возвращает true/false, есть ли у elem класс - без точки

  elem.tagName

  elem.className.includes() // проверяет наличие класса, true/false - без точки
  elem.className.matches // проверяет по селектору

  element.matches(selectorString); // true если соответствует
  for (var i = 0; i &lt; elems.length; i++) {
    if (elems[i].matches('a[href$="zip"]')) {
      alert( "Ссылка на архив: " + elems[i].href );
    }
</pre>
      </section>
      <section>
        <h4>Создание элемента + Добавление в DOM-дерево</h4>
        <ol>
          <li>
            <p>Создавать элементы можно разными способами, мы будем использовать метод <b>createElement()</b> объекта document:</p>
<pre>
  var card = document.createElement('li');
</pre>
            <p>Обратите внимание, что createElement — метод именно объекта document. То есть с его помощью мы создаём какой-то элемент для этого документа, пока не указывая, где он будет находиться в DOM.</p>
          </li>
          <li>
            <p>Вновь созданный элемент по умолчанию не находится в DOM-дереве и не отображается на странице. Мы просто храним его в переменной. Чтобы он появился на странице, его нужно добавить в DOM. Для этого элемент нужно поместить в его родителя. </p>
<pre>
  <b>list.appendChild(card);</b> - Добавляет elem в конец дочерних элементов parentElem.
  <b>parentElem.insertBefore(elem, nextSibling)</b> // Вставляет elem в коллекцию детей parentElem, перед элементом nextSibling.
  <b>list.insertBefore(newLi, list.firstChild);</b> // вставить элемент первым, или вот так: <b>list.insertBefore(newLi, list.childNodes[0]);</b> // если вторым аргументом указать null, то как appendChild
  <b>someElem.parentNode.insertBefore(otherElem, someElem.nextSibling);</b> // вставить элемент после другого элемента, либо же последним
</pre>
            <p>Можно создать элемент с помощью createElement и сразу вставить его в родительский элемент, а уже затем добавлять классы. Но это не лучший путь — каждое изменение в DOM вызывает перерисовку страницы, а это дорогая операция, она занимает много времени.</p>
          </li>
          <li>
<pre>
  // Функция для создания элемента
  var makeElement = function (tagName, className, text, parent) {
    if (tagName) { var element = document.createElement(tagName) };
    if (className) { element.classList.add(className) };
    if (text) { element.textContent = text; }
    if (parent) { parent.appendChild(element); }
    return element;
  };                
</pre>
          </li>
        </ol>
      </section>
      <section>
        <h4>Добавление текстового содержимого</h4>
        <p>У каждого DOM-элемента есть свойство textContent. Оно содержит текстовое содержимое элемента. В textContent не попадает разметка, только текст.</p>
<pre>
    console.log(p.textContent);
    // Выведет 'Я — текстовый элемент.'
    // Это свойство объекта, которое можно не только прочитать, но и записать или перезаписать:
    p.textContent = 'Теперь у меня новое содержимое.';
    console.log(p.textContent);
    // Выведет 'Теперь у меня новое содержимое.'
    // В HTML содержание тега изменится               
</pre>
        <p>Добавлять содержимое в HTML-элемент через JavaScript можно и с помощью свойства innerHTML. Присвоенная свойству innerHTML строка заменяет всё содержимое HTML-элемента. В этой строке можно использовать любой HTML-код.</p>
<pre>
  var control = document.querySelector('.control');
  control.innerHTML = 'walden';
</pre>
        <p> 
          1. innerHTML parses content as HTML and takes longer.<br>
          2. nodeValue is a little more confusing to use, but faster than innerHTML.<br>
          3. innerText Takes styles into consideration. It won't get hidden text for instance.<br>
          4. textContent uses straight text, does not parse HTML, and is faster.<br>
          5. “”someElement””.firstChild.data - только текст элемента
        </p>
      </section>
      <section>
        <h4>Создание/удаление/перестановка элементов</h4>
        <ol>
          <li>
            <p>Клонирование/копирование DOM-узлов</p>
<pre>
  elem.cloneNode(true) // создаёт «глубокую» копию элемента – вместе с атрибутами включая c подэлементами. Если с аргументом false – копия без дочерних элементов.
</pre>
          </li>
          <li>
            <p>Удаление узлов/элементов</p>
<pre>
  <b>parentElem.removeChild(elem)</b> // Удаляет elem из списка детей parentElem.
  <b>elem.remove()</b> // var el = document.getElementById('div-02'); el.remove()
  <b>parentElem.replaceChild(newElem, elem)</b> // удаляет elem и вставляет на его место newElem.
  elem.innerHTML = ''; // очистка DOM-элемента                
</pre>
          </li>
          <li>
            <p>Перестановка элементов</p>
<pre>
  // нет необходимости в предварительном removeChild(last). Кроме того, все методы вставки автоматически удаляют вставляемый элемент со старого места.
  var first = document.body.children[0];
  var last = document.body.children[1];
  document.body.insertBefore(last, first); // поменять местами                
</pre>
          </li>
        </ol>
      </section>
      <section>
        <h4>Атрибуты и JS, dataset</h4>
        <p>
          <br>
          - Всегда являются строками.<br>
          - Их имя нечувствительно к регистру (ведь это HTML)<br>
          - Видны в innerHTML (за исключением старых IE)
        </p>
<pre>
  <b>elem.hasAttribute(name)</b> // проверяет наличие атрибута
  <b>elem.getAttribute(name)</b> // получает значение атрибута
  <b>elem.setAttribute(name, value)</b> // устанавливает атрибут
  <b>elem.removeAttribute(name)</b> // удаляет атрибут
  <b>Some.attributes</b> // получить атрибуты элемента  
    
  var some = document.querySelector('.page-header__small');
  var attrs = some.attributes;
  for (var i = 0; i &lt; attrs.length; i++) {
    console.log(attrs[i].name + " = " + attrs[i].value);
  }
</pre>
        <p>
            - Есть и другие атрибуты, которые не копируются в точности. «Логические» свойства вроде checked, selected всегда имеют значение true/false, а HTML-атрибут checked – любое строковое, важно лишь его наличие.<br>
            - Свойство зависит от атрибута, но не наоборот. При изменении свойства input.value атрибут input.getAttribute('value') не меняется.<br>
            - Атрибуту "class" соответствует свойство className. Атрибуту for → htmlFor.
        </p>
        <p>
          Элементу можно задавать любой атрибут, валидатор не будет против. Для нестандартных (не описано в стандарте) атрибутов DOM-свойство не создаётся. Манипулировать атрибутом из JavaScript проще чем классом, так как значение атрибута – произвольная строка, значение класса – это «есть» или «нет».
        </p>
<pre>
  // Например, если нужно отменить заказ, неважно в каком он состоянии сейчас – это сделает код
  div.setAttribute('order-state', 'canceled');
  // Для классов – нужно знать, какой класс у заказа сейчас. И тогда мы можем снять старый класс, и поставить новый:
  div.classList.remove('order-state-new');
  div.classList.add('order-state-canceled');
</pre>
        <p>Как правило нестандартные атрибуты записывают через 'data-[...]'. К таким атрибутам можно обратиться как к свойствам, при помощи свойства dataset:</p>
<pre>
  elem.dataset.about // elem.dataset.userLocation
</pre>
        <p>Важно понимать, что дефис в СSS превращается в большую букву в JS.</p>
<pre>
  //Показать / скрыть элемент:
  element.hidden = !element.hidden; // или через if
</pre>
      </section>
    </section>

    <section class="content-section" id="events">
      <h3>Events</h3>
      <section>
        <h4>Общее</h4>
        <p>№1. HTML-атрибут onclick="alert('Клик!')"</p>
        <p>№2. JS-1. Обьявить анонимную функцию либо назначить уже существующую:</p>
<pre>
  button.onclick = function() {
    alert( 'Клик!' );
  };
  // либо так. Если добавить скобки, то sayThanks() – будет уже результат выполнения функции (а так как в ней нет return, то в onclick попадёт undefined)
  function sayThanks() {
    alert( 'Спасибо!' );
  }
  elem.onclick = sayThanks;
</pre>
        <p>Вешать через назначение атрибута - работать не будет.</p>
        <p> №3. JS-2: addEventListener и removeEventListener</p>
        <p>Для удаления нужно передать именно ту функцию-обработчик которая была назначена (а может быть передана ругая, с одинаковым кодом). не сохранить где-либо, а просто передать в addEventListener, как в предыдущем коде, то потом получить её обратно, чтобы снять обработчик, будет невозможно. Нет метода, который позволяет считать обработчики событий, назначенные через addEventListener.</p>
      </section>
      <section>
        <h4>Всплытие</h4>
        <p>При наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности. События «всплывают» от внутреннего элемента вверх через родителей, подобно тому, как всплывает пузырек воздуха в воде. Событие focus не всплывает.</p>
        <p>Cобытие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через on* и addEventListener(...., false).Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента <form>, на котором сработает обработчик.</p>
<pre>
  form onclick="alert('form')
    div onclick="alert('div')
      p onclick="alert('p')
</pre>
        <p>Чтобы поймать событие на стадии перехвата, нужно использовать третий  (event.eventPhase) аргумент addEventListener: если true, событие будет перехвачено по дороге вниз, если false - наоборот, сейчас это используется редко.</p>
      </section>
      <section>
        <h4>Делегирование событий</h4>
        <p>Если есть много элементов, события на которых нужно обрабатывать похожим образом, вместо того, чтобы назначать обработчик каждому – ставим один обработчик на их общего предка. Из него можно получить целевой элемент event.target, понять на каком потомке произошло событие и обработать его.</p>
        <p>Обработчик table.onclick с циклом while для изменения ячеек таблицы, с учётом того, что event.target может быть не ячейка, а тег внутри её:</p>
<pre>
  table.onclick = function(event) {
    var target = event.target;
    // цикл двигается вверх от target к родителям до table
    while (target != this) {    // или так: var td = target.closest('td');
  
      if (target.tagName == 'TD') {
        // нашли элемент, который нас интересует!
        highlight(target);
        return;
      }
      target = target.parentNode;
    }
    // возможна ситуация, когда клик был вне <td>
    // если цикл дошёл до table и ничего не нашёл,
    // то обработчик просто заканчивает работу
  }
</pre>
        <p>Делегирования для разных событий</p>
<pre>
  function menuAddEvent(someMenu) {
    someMenu.addEventListener('click', function(evt) {
      var attr = evt.target.getAttribute('data-action');
      if (attr) {
        if (attr === 'save') {
          console.log('Сохраняю!');
        } else if (attr === 'load') {
          console.log('Загружаю...');
        } else if (attr === 'search') {
          console.log('Ищу, хозяин!');
        }
      }   
    });
  }
  menuAddEvent(menu);            
</pre>
        <p>
          Вешаем обработчик на контейнер.<br>
          В обработчике: получаем event.target.<br>
          В обработчике: если event.target или один из его родителей в контейнере (this) – интересующий нас элемент – обработать его.    
        </p>
        <p class="important">Приём проектирования "поведение"<pr>
        <p>На родителя вешает один обработчик, для детей - определять работу того или иного элемента по data-* (или другому атрибуту) с помощью event.target</p>
      </section>
      <section>
        <h4>evt.target vs this</h4>
        <p>event.target – это исходный элемент, на котором произошло событие, в процессе всплытия он неизменен.<br>this – это текущий элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.</p>
<pre>
  /*
  div 1
    p some paragraph
  div
  */

  document.querySelector('div').addEventListener('click', function(evt) {  // берет имеено evt.target,
    содержит ссылку на конкретный элемент внутри формы, самый вложенный, на котором произошёл клик (до которого «доплыло» событие)
    evt.target.style.backgroundColor = 'gray';
    console.log(evt.target.tagName);
  });
  
  // document.querySelector('div').addEventListener('click', function(evt) { // берет сам элемент
  //   this.style.backgroundColor = 'gray';
  //   console.log(this.tagName);
  // });
</pre>
<pre>
  // <b>свойства объекта event
    event.target 
    event.type
    event.currentTarget 
    event.clientX / event.clientY - Координаты курсора в момент клика (относительно окна)
    evt.preventDefault()
    event.stopPropagation()
    event.stopImmediatePropagation() // остановить другие обработчики на элементе</b>
</pre>
      </section>
      <section>
        <h4>Пример кода</h4>
<pre>
  var popup = document.querySelector('.modal');
  var openPopupButton = document.querySelector('.button-open');
  var closePopupButton = popup.querySelector('.button-close');
  
  openPopupButton.addEventListener('click', function (evt) {
    evt.preventDefault();
    popup.classList.add('modal--show');
  });
  
  closePopupButton.addEventListener('click', function() {
    popup.classList.remove('modal--show');  
  });            
</pre>
      </section>
      <section>
        <h4>Как повесить обработчик на нажатие клавиши?</h4>
        <p>У события «нажатие на клавишу» есть специальное название — keydown. Такое событие срабатывает при нажатии на любую клавишу. Обратите внимание, слушать это событие можно только на элементах, которые имеют состояние фокуса: поля ввода, кнопки, элементы с атрибутом tabindex, документ. При нажатии фокус должен находиться на соответствующем элементе.</p>
<pre>
  document.addEventListener('keydown', function(evt) {
    // 
  });            
</pre>
        <p>У объекта события есть много полезных свойств. Например, тип события, введённый символ, координаты курсора в момент наступления события и многое другое. В том числе и код клавиши, которую нажал пользователь. Это свойство называется keyCode. С помощью этого свойства каждую клавишу можно определить по коду. Например, у Enter код 13, а у ESC — код 27. Эти номера универсальны и одинаковы в любой раскладке. Найти код любой клавиши можно здесь.</p>
      </section>
    </section>

    <section class="content-section" id="JS-math">
      <h3>JS math</h3>
      <section>
        <h4>Math.floor() /// Math.ceil() /// Math.round() /// num.toFixed(precision)</h4>
        <p>Для округления до n цифры после запятой: умножить и поделить на 10 с нужным количеством нулей. var n = 3.456; alert( Math.round(n * 100) / 100 ); // 3.46 --------- num.toFixed(precision) - округляет число num до точности precision и возвращает результат в виде строки. Округляет аналогично Math.round и дополняется нулями до нужной точности. Если нам нужно число, то делаем +n.toFixed(..) К методу числа можно обратиться и напрямую. Но если число целое, то будет проблема: alert(12.toFixed(1)); // ошибка! Ошибка произойдёт потому, что JavaScript ожидает десятичную дробь после точки. Это – особенность синтаксиса JavaScript. Вот так – будет работать: alert( 12..toFixed(1) ); // 12.0. Не идентичен </p>
      </section>
      <section>
        <h4>Math random - случаное число от 0 до 1</h4>
<pre>
  Math.floor(Math.random() * (max - min + 1) + min)
  var randomNumber = Math.round(min - 0.5 + Math.random() * (max - min + 1)); 
  Math.ceil ??
</pre>
        <p>Math.max(a, b, c...) /// Math.min(a, b, c...) - Возвращает наибольший/меньший из списка аргументов</p>
      </section>
      <section>
        <h4>Другое</h4>
<pre>
  Math.pow(n,y) - возведение n к степени y  
  Math.abs() - возвращает модуль числа
  Math.sqth()- квадратный корень - Для отрицательных чисел Math.sqrt() возвращает NaN (не число - корней нет)
  Math.PI
  Math.LOG10E
  number.toLocaleString() - для красивого вывода чисел
  
  eval() - выполняет код со строки            
</pre>
      </section>
    </section>

    <section class="content-section" id="JS-time">
      <h3>JS time</h3>
      <section>
        <h4>Таймеры</h4>
        <p><b>setTimeout</b></p>
<pre>
  var timerId = setTimeout(func / code, delay[, arg1, arg2...]) // запускает функцию через определённое время
  - func - без вызова!. ПОддерживаются строки, но лучше не использовать
  - delay - задержка в миллисекундах, 1000 миллисекунд равны 1 секунде.
  - [, arg1, arg2...] - аргументы, которые нужно передать функции              
</pre>
        <p>setInterval</p>
        <pre>
          var timerId = setInterval(func / code, delay[, arg1, arg2...]) // похожий синтаксис, но запускает выполнение функцию не один раз, а повторяет её через указанный интервал.
        </pre>
      </section>
    </section>

    <a href="#to-top" class="button-scroll"></a>
	</main>
  
  <script src="script.js"></script>
</body>
</html>
