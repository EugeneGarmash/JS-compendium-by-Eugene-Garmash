<!DOCTYPE html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<title>JavaScript compendium</title>
	<meta name="description" content="JS compendium written by some jerky coder">
  <meta name="keywords" content="JS, JavaScript, EcmaScript, JS5, JS6, JS7, JS8, programming, programming language">
  <meta name="author" content="Eugene Garmash">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="normalize.css">
  <link rel="stylesheet" href="customResetEugeneGarmash.css">
	<link rel="stylesheet" href="style.css">
</head>

<body>

	<header>

		<nav class="navbar">
			<div class="navbar__nav-header">
				<h1>JavaScript compendium</h1>
				<p class="navbar-header__written-by">written by <br>
          <a href="https://github.com/EugeneGarmash">Eugene Garmash<sup>link</sup></a>
        </p>
        <p class="shown-when-mobile">Scroll down or click below to go to the section</p>
      </div>
			<ul class="navbar__list">
        <li>
          <a href="#general-information">
            Вступление
          </a>
        </li>
        <li>
          <a href="#conditions">
              Условия
          </a>
        </li>
        <li>
          <a href="#numbers-n-co">
            Числа, операторы и преобразование
          </a>
        </li>
        <li>
          <a href="#loops">
            Циклы
          </a>
        </li>
        <li>
          <a href="#arrays">
            Массивы
          </a>
        </li>
        <li>
          <a href="#functions"> 
            Функции
          </a>
        </li>
        <li>
          <a href="#strings">
            Строки
          </a>
        </li>
        <li>
          <a href="#closures">
            Замыкания
          </a>
        </li>
      </ul>
    </nav>
    
  </header>


  <main>
    <h2 class="visually-hidden" id="to-top">Compendium text</h2>

    <section class="content-section" id="general-information">
      <h3>Вступление</h3>
      <section>
          <h4>Общая информация</h4>
          <p>Настоящее название – ECMAScript. DOM – Document Object Model </p>   
      </section>
      <section>     
        <h4>Комментарии</h4>
<pre>
  // Эта строка кода не выполнится. Однострочный комментарий.
  /*
  Все эти строки кода не выполнятся.
  Так как это многострочный комментарий.
  */
</pre>
      </section> 
      <section>
        <h4>Вывод в консоль:</h4>
<pre>
  console.log(переменные и действия);
  console.log('Привет от Кекса!');
  console.info;
</pre>
      </section>
      <section>
        <h4>Терминология на английском:</h4>
        <ul class="list-restored"> 
          <li>Инструкция  - statement</li>
          <li>присваивание – assignment</li>
          <li>выражение – expression</li>
          <li>значение – value</li>
          <li>пустое место – white space</li>
          <li>цикл – loop</li>
          <li>параметр – parameter</li>
          <li>аргумент – argument</li>
          <li>свойство объекта - property</li>
        </ul>
      </section>
      <section>
        <h4>Типы данных:</h4>
        <p> (Примитивные – типы данных, о которых можно сказать только то, чему они равны)</p>
        <ul class="list-restored">
          <li>number — числа (в JS числовой тип включает и целые, и дробные числа. В некоторых других языках это разные типы данных), Infinity, -Infinity and  Not a Number (NaN)</li>
          <li>string — строки, Тип символ не существует, есть только строка</li>
          <li>symbol</li>
          <li>boolean — логические или булевы значения, «истина» или «ложь»</li>
          <li>спец. знач. null – значение неизвестно. Null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно»</li>
          <li>специальное значение undefined – значение не присвоено / неопределено</li>
          <li>Массив (составной тип – несколько значений), array, хранит последовательность значений и порядок этих значений важен.
<pre>
  // Массив
  [1, 2, 3, 4, 5]
</pre>
          </li>
          <li>Объект (составной тип – несколько значений), object, состоит из множества пар «ключ-значение», порядок этих пар не важен
<pre>
  // Объект
  {
  month: 'june', 
  day: 15
  }
</pre>
          </li>
        </ul>
      </section>
      <section>
        <h4>Переменные</h4>
        <p>Переменная — название для данных, которое можно делать понятным для людей. Два самых популярных способа для названий: camelCase (верблюжья нотация) и snake_case (змеиная нотация; + венгерская нотация ( в имени указывают тип данных)).</p>
<pre>
  var имяПеременной;
  var someVariable;
</pre>
        <p>После создания переменной её можно использовать в других командах, например, выводить в консоль:</p>
<pre>
  // Обратите внимание, что кавычек нет!
  console.log(имяПеременной);
</pre>
        <p>Помимо объявления переменной нужно присвоить ей какие-то данные. Для операции присваивания используется знак равенства:</p>
<pre>
  var milkInGrams;              	// Объявляем переменную
  console.log(milkInGrams);     	// Выведет undefined
  milkInGrams = 20;             	// Присваиваем одно значение
  console.log(milkInGrams);     	// Выведет 20
</pre>
        <p>Команда var используется один раз, дальше обращаетесь к переменной без var. Если вы повторно задаёте значение переменной, вы меняете значение переменной. Объявление + присваивание: </p>
<pre>
  var milkCalories = 42;
  var dryFeedCalories = keks.ask('Сколько калорий в сухом корме?');
  var dailyMealInGrams = 50 + 80 + 120;
</pre>
        <p class="important">Важно:</p>
        <ul class="list-restored">
          <li>Имена переменных в JavaScript чувствительны к регистру. myname и myName — это две разных переменных.</li>
          <li>Имя переменной должно начинаться с латинской буквы и может содержать только латинские буквы и цифры (а также $ и _).</li>
          <li>В качестве имени переменной нельзя использовать специальные ключевые слова, такие как var или if (class, return, export и другие).</li>
          <li>Можно объявить несколько переменных сразу: 
<pre>
  var user = 'John', age = 25, message = 'Hello';
</pre>
          </li>
          <li> Присваивайте переменные в начале области видимости. Это помогает избегать проблем с объявлением переменных и областями видимости. Объявляйте переменные, которым не присваивается значение, в конце. Это удобно, когда вам необходимо задать значение одной из этих переменных на базе уже присвоенных значений.
<pre>
  // плохо
  var i, items = getItems(),
  dragonball,
  goSportsTeam = true,
  len;
  // хорошо
  var items = getItems(),
      goSportsTeam = true,
      dragonball,
      length,
      i;
</pre>
          </li>
        </ul>
      </section>
      <section>
        <h4>Операции</h4>
<pre>
  50 + 100;
</pre>
        <p>Это операция. Она состоит из знака операции, +, или оператора, и двух операндов, 50 и 100. Операция сложения — бинарная, так как в ней два операнда. Бинарные операции самые распространённые. Но существуют и унарные операции, с одним операндом, и тернарные операции, с тремя операндами. В качестве операндов можно использовать переменные:</p>
<pre>
  breakfastCalories + dinnerCalories;
  milkInGrams * 0.5;
  50 + waterInGrams;
</pre>
        <p>Над разными типами операндов можно производить разные операции, поэтому важно понимать, данные какого типа хранятся в переменных. И здесь очень помогает команда console.log(). Вот операции: Сложение (+), Вычитание (-), Умножение (*), Деление (/). А вот как результату операци присвоить переменную:</p>
<pre>
  var totalWaterInGrams = milkInGrams + waterInGrams;
</pre>
        <p>В одной команде можно использовать сразу несколько операций. Порядок выполнения операций будет зависеть от их приоритетов. Если в выражении есть только арифметические операции, то их приоритет такой же, как в школе: умножение и деление имеют высший приоритет, сложение и вычитание низший. У присваивания один из самых низких приоритетов. Именно поэтому, когда переменную чему-либо присваивают, например, x = 2 * 2 + 1 сначала выполнится арифметика, а уже затем – произойдёт присваивание =.</p>
      </section>
      <section>
        <h4>Операции со строками:</h4>
        <p>У каждого типа данных свои операции. Арифметические операции можно производить с числами, но не со строками. Самая важная строковая операция — это «склеивание» строк или конкатенация строк. Например:</p>
<pre>
  var name = 'Кекс';
  'Инструктор' + 'Кекс';  // результат: 'ИнструкторКекс'
  'Инструктор ' + 'Кекс'; // результат: 'Инструктор Кекс'
  'Инструктор ' + name;   // результат: 'Инструктор Кекс'  
</pre>
        <p>Что будет, если операнды разного типа?</p>
<pre>
  'Молоко, гр: ' + 50; 	// результат: 'Молоко, гр: 50'
  '2' * 50;            	// результат: 100 
</pre>
        <p>В этом случае JavaScript попытается привести операнды к одному типу и выполнить операцию. Подходящий тип будет выбираться в зависимости от операции. <br>
        - Плюс может быть знаком сложения или конкатенации, но так как один из операндов — строка, то сложение не подходит. Поэтому число 50 приводится к строке '50' и склеивается со строкой 'Молоко, гр: '. <br>
        - Звёздочка — это знак умножения. Поэтому JavaScript пытается превратить строку '2' в число, и у него это получается. Затем числа 2 и 50 перемножаются, и получается 100. <br>
        - Из-за того, что JavaScript умеет изменять тип операндов на лету, он называется языком с динамическим приведением типов. <br></p>
        <p class="important">Важно:</p>
        <p>Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!</p>
      </section>
      <section>
        <h4>Оператор typeof</h4>
        <p>возвращает тип аргумента (то, что в скобках). Синтаксис оператора: <br> 
            - typeof x <br>
            - typeof(x) <br>
      </section>
    </section>


    <section class="content-section" id ="conditions">
      <h3>Условия ("if" / ? / switch)</h3>
      <section>
        <h4>"if" statements</h4>
        <p>Представим, что нам нужно чтобы программа стала нелинейной: в зависимости от разных условий она должна выполнять разные команды. Для проверки условий используют условный оператор if:</p>
<pre>
  if (условие) {
  действия;
  }
</pre>
        <p>Здесь «условие» — это выражение, возвращающее true или false, а «действия» внутри фигурных скобок — это команды, которые выполняются, если условие удовлетворено.</p>
<pre>
  var foodInGrams = 60;
  var dayLimit = 80;
  if (foodInGrams &lt; dayLimit) {
      console.log('Ещё можно!');
  }
</pre>
      </section>
      <section>
        <h4>Else</h4>
<pre>
  if (условие) {
    действия;
  } else {
    другие действия;
  }            
</pre>
        <p>Ветка «действия» срабатывает, если условие выполнено. Ветка «другие действия» срабатывает, если условие не выполнено. "Если условие выполняется, сделай действие, иначе сделай другие действия".</p>
      </section>
      <section>
        <h4>Вложенные условия</h4>
        <p>Что делать, если принятие решения зависит не от одного, а от двух и более условий? Использовать один if, а затем, если условие выполнилось, выполнить ещё одно условие внутри вложенного if:</p>
<pre>
  if (условие1) {
    if (условие2) {
      действия;
    }
  }            
</pre>
      </section>
      <section>
        <h4>Else if</h4>
        <p>Бывает нужно проверить несколько вариантов условия. Для этого используется блок else if:</p>
<pre>
  var year = prompt('В каком году появилась спецификация ECMA-262 5.1?', '');         
  if (year &lt; 2011) {
    alert( 'Это слишком рано..' );
  } else if (year > 2011) {
    alert( 'Это поздновато..' );
  } else {
    alert( 'Да, точно в этом году!' );
  }            
</pre>
      </section>
      <section>
        <h4>Оперератор вопросительный знак ‘?’</h4>
        <p>условие ? значение1 : значение2 - для присваивания переменной в зависимости от условия</p>
<pre>
  var access;
  var age = prompt('Сколько вам лет?', '');
  var result = true ? 1 : 0;
  
  // Так будет долго:
  if (age > 14) {
    access = true;
  } else {
    access = false;
  }
  alert(access);

  // А вот так - коротко:
  access = (age > 14) ? true : false;

  var age = prompt('Сколько Вам лет?', '');
  var message = 
    (age &lt; 3) ? 'Здравствуй, малыш!':
    (age &lt; 18) ? 'Привет!':
    (age &lt; 100) ? 'Здравствуйте!':
    'Какой необычный возраст!';
</pre>
        <p class="important">Важно:</p>
        <p>Нельзя использовать break/continue справа от оператора „?“. Смысл оператора '?' – вернуть то или иное значение, в зависимости от условия. Пожалуйста, используйте его по назначению, а для выполнения разных веток кода есть if.</p>
      </section>
      <section>
        <h4>Switch</h4>
        <p>Конструкция switch заменяет собой сразу несколько if. Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.</p>
<pre>
  switch(x) {
    case 'value1':  // if (x === 'value1')
      ...
      [break]
    case 'value2':  // if (x === 'value2')
      ...
      [break]
    default:
      ...
      [break]
</pre>
        <ul class="list-restored">
          <li>Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.</li>
          <li>Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).</li>
          <li>Если ни один case не совпал – выполняется (если есть) вариант default.</li>
          <li>Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.</li>            
        </ul>
<pre>
  var a = 2 + 2; // Пример
  switch (a) {
    case 3:
      alert( 'Маловато' );
      break;
    case 4:
      alert( 'В точку!' );
      break;
    case 5:
      alert( 'Перебор' );
      break;
    default:
      alert( 'Я таких значений не знаю' );
  }            
</pre>
        <p>Группировка case</p>
<pre>
  case 3:                    // (*)
  case 5:                    // (**)
    alert('Неверно!');
    alert('Немного ошиблись, бывает.');
    break;
  // При case 3 выполнение идёт со строки (*), при case 5 – со строки (**).
</pre>
        <p class="important">Важно:</p>
        <p>Оператор switch предполагает строгое равенство (рассмотрено дальше, ===).</p>
      </section>
      <section>
        <h4>Задания</h4>
        <ol class="ordered-list-restored">
          <li>
            <p>Программа должна анализировать числа. Если число делится на 3, результат работы программы — строка 'Fizz'. Если число делится на 5 — строка 'Buzz'. Если число одновременно делится на 3 и на 5 — результат 'FizzBuzz'. В остальных случаях результат работы программы — изначальное число. Число записано в переменную number. Результат работы программы записывайте в переменную taskResult. </p>
<pre>
    var number = 15;
    var taskResult;    
</pre>
            <label class="question" for="conditions1">Показать ответ</label>
            <input type="checkbox" id="conditions1" class="visually-hidden">
<pre>
  1
  if (number % 3 == 0 && number % 5 == 0) {
    taskResult = 'FizzBuzz';
  } else if (number % 3 == 0) {  // или вместо равнения к нулю ставить (!...) 
    taskResult = 'Fizz';
  } else if (number % 5 == 0) {
    taskResult = "Buzz";
  } else {
    taskResult = number;
  }
  2 - креативно
  var fizz = number % 3;
  var buzz = number % 5;
  taskResult = number;
  var fizz = ...; 
  var buzz = ...;
  var fizzbuzz = ...;
    if (!fizz) {
  taskResult = 'Fizz';
  }
  if (!buzz) {
  taskResult = 'Buzz';
  }
  if (!fizz && !buzz) {
  taskResult = 'FizzBuzz';
  }
  3 - короче всего
  taskResult = number;
  if (!(number%3) && (number%5)) {
    taskResult = "Fizz";
  }
  if (number%3 && !(number%5)) {
    taskResult = "Buzz";
  }
  if (!(number%3) && !(number%5)) {
    taskResult = "FizzBuzz";
  }
</pre>
          </li>
          <li>
            <p>Напиши программу, которая будет рассчитывать сумму покупки с учётом скидки. Если стоимость покупки от 1000 (включительно) до 3000 (не включая это значение), скидка составляет 5%. Если стоимость покупки от 3000 (включительно) до 5000 (не включая это значение), скидка 10%. Если стоимость покупки от 5000 (включительно) и выше, скидка 15. В остальных случаях скидки для покупателей нет. Вычисляй стоимость с учётом скидки и записывай результат в переменную discountedBuy. Для того чтобы проверить код создай переменную buy до условия и меняй в ней значения, результат выводи в консоль либо alert(...)</p>
            <label class="question" for="conditions2">Показать ответ</label>
            <input type="checkbox" id="conditions2" class="visually-hidden">
<pre>
  if (buy &lt; 1000) {
    discountedBuy = buy;
  } else if (buy >= 1000 && buy &lt; 3000) {
    discountedBuy = buy * 0.95;
  } else if (buy >= 3000 && buy &lt; 5000) {
    discountedBuy = buy * 0.90;
  } else {
    discountedBuy = buy * 0.85;
  }                
</pre>
          </li>
          <li>
            <p> Напиши программу для расчёта длительности прогулки. Она зависит от нескольких условий. Если идёт дождь, гулять я не хожу. В этом случае длительность прогулки равняется 0. А вот если дождя нет, всё зависит от температуры на улице: Во-первых, если температура от 10°C (включительно) до 15°C (не включая это значение), я гуляю 30 минут. Во-вторых, если температура от 15°C (включительно) до 25°C (не включая значение), я гуляю 40 минут. В-третьих, при температуре от 25°C (включительно) до 35°C (включительно), я гуляю 20 минут. В остальных случаях я никуда не выхожу: либо очень холодно, либо очень жарко. Результат программы – время прогулки. Его необходимо записать в переменную minutes.</p>
<pre>
    // переменные для твоего кода
    var temperature = 20; // меняй чтобы проверить
    var itsRaining = false; // меняй для другого результата
    var minutes;
</pre>
            <label class="question" for="conditions3">Показать ответ</label>
            <input type="checkbox" id="conditions3" class="visually-hidden">
<pre>
// 1
  if (isRaining || temperature &lt; 0 || temperature > 35) {
    minutes = 0;
  } else if (temperature >= 10 && temperature &lt; 15) {
    minutes = 30;
  } else if (temperature >= 15 && temperature &lt; 25) {
    minutes = 40;
  } else {
    minutes = 20;
  }
// 2 - хуже, но тоже логично
  if (!isRaining) {
    if (10 &lt;= temperature && temperature &lt; 15) {
      minutes = 30;
    }
    if (15 &lt;= temperature && temperature &lt; 25) {
      minutes = 40;
    }
    if (25 &lt;= temperature && temperature &lt;= 35) {
      minutes = 20;
    }
    if (10 > temperature || temperature > 35) {
      minutes = 0;
    }
  } else {
    minutes = 0;
  }
// 3 - самый продвинутый вариант
if (itsRaining == true || temperature &lt; 0 || temperature > 35) {
  minutes = 0;
} else {
  minutes = 20 -  Math.abs(temperature - 20);
}
</pre>
          </li>
        </ol>
      </section>
    </section>
    
    
    <section class="content-section" id="numbers-n-co">
      <h3>Числа, операторы и преобразование</h3>
      <section>
        <h4>Операторы «больше» > и «меньше» &lt;, «больше или равно» >=, «меньше или равно» &lt;=</h4>
        <p>Как и другие операторы, сравнение возвращает значение. Это значение имеет логический тип ‘False’ or ‘True’: </p>
<pre>
  if (red &lt; yellow) {
    console.log('Красные маркеры в меньшинстве. Прогноз умеренно позитивный!');
  } else {
    console.log('Неправильно! Прогноз неприемлем!');
  }
</pre>
        <p>Строки сравниваются побуквенно. В кодировке Unicode обычно код у строчной буквы больше, чем у прописной, поэтому регистр имеет значение. Для корректного сравнения символы должны быть в одинаковом регистре. Если строка состоит из нескольких букв, то сравнение осуществляется как в словаре.</p>
<pre>
  alert( 'Б' > 'А' ); // true
  alert( 'Банан' > 'Анна' );
  alert( 'Вася' > 'Ваня' ); // true, т.к. 'с' > 'н'
  alert( 'Привет' > 'Прив' ); // true, так как 'е' больше чем "ничего".
</pre>
        <p>Числа и строки сравнивать нельзя, результат будет неверен. В примере ниже 2 оказалось больше 14, потому что строки сравниваются посимвольно, а первый символ '2' больше '1'. Правильно было бы преобразовать их к числу явным образом. Например, поставив перед ними +. При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям.</p>
<pre>
  alert( "2" > "14" ); // true, неверно, ведь 2 не больше 14
  alert( +"2" > +"14" ); // false, теперь правильно

  alert( '2' > 1 ); // true, сравнивается как 2 > 1
  alert( '01' == 1 ); // true, сравнивается как 1 == 1
  alert( false == 0 ); // true, false становится числом 0
  alert( true == 1 ); // true, так как true становится числом 1.
</pre>
      </section>
      <section>
        <h4>Равенство</h4>
        <img src="images/comparison.png" alt="comparison">
<pre>
  console.log('123' == 123); // Выведет true
  console.log('123' != 123); // Выведет false            
</pre>
        <p>Строка и число окажутся равны друг другу. Так происходит, потому что при сравнении разных типов с помощью == происходит преобразование значений к единому типу. Из строки '123' можно получить число 123. По этой же причине неравенство != возвращает для этих значений false.</p>
        <p class="important">Важно: </p>
        <p>.</p>
        <img src="images/comparison__2.png" alt="comparison__2">
        <ul>
          <li>Числа и строки приводятся по-особому. Например, все числа кроме 0 — true, при этом 0 — false. Все строки, кроме пустой строки — true, пустая строка '' — false. Можно сказать, что значения, которые как бы ничего в себе не содержат (как 0 или пустая строка ), приводятся к false, а все остальные приводятся к true. Кратко говоря, число 0, пустая строка "", null и undefined, а также NaN являются false. Все остальное – true</li>
          <li>Преобразование null и undefined. Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка. При преобразовании в число null становится 0, а undefined становится NaN. Дело в том, что алгоритмы проверки равенства == и сравнения >= > &lt; &lt;= работают по-разному. Сравнение честно приводит к числу, получается ноль. А при проверке равенства значения null и undefined обрабатываются особым образом: они равны друг другу, но не равны чему-то ещё. Значение undefined вообще нельзя сравнивать, всегда будет false кроме null.Сравнение приводит null к числу  (0), а равенство  - нет.
          Вывод: любые сравнения с undefined/null, кроме точного ===, следует делать с осторожностью. Желательно не использовать сравнения >= > &lt; &lt;= с ними, во избежание ошибок в коде.
<pre>
  alert( null > 0 ); // false
  alert( null == 0 ); // false
  alert(null >= 0); // true                
</pre>
          </li>
          <li>Использовать строгое равенство — хорошая практика. Используйте именно его во всех случаях, где это возможно</li>
        </ul>
      </section>
      <section>
        <h4>Операторы %, + (унарный плюс) и запятая, приоритет операторов</h4>
        <p>Приоритет операторов:</p>
        <img src="images/priority.png" alt="priority">
        <img src="images/priority__2.png" alt="priority__2">
        <img src="images/priority__3.png" alt="priority__3">
        <p>% - оператор «остаток от деления» - возвращает остаток от деления чисел. Работает это так:</p>
<pre>
  12 % 5;  // Вернёт 2	
  27 % 3;  // Вернёт 0
  13 % 3;  // Вернёт 1            
</pre>
        <p>Оператор “унарный плюс”. Так как «унарный плюс» имеет приоритет 15, выше, чем 13 у обычного «сложения», то в выражении +apples + +oranges сначала сработали плюсы у apples и oranges, а затем уже обычное сложение. «Побочный эффект унарного плюса» – преобразование значения в число. Например, когда мы получаем значения из HTML-полей или от пользователя, то они обычно в форме строк. Его «побочный эффект» – преобразование значения в число. А что, если их нужно, к примеру, сложить? Бинарный плюс сложит их как строки:</p>
<pre>
  var apples = "2";
  var oranges = "3";
  alert( +apples + +oranges ); // 5, число, оба операнда предварительно преобразованы в числа            
</pre>
        <p>Оператор запятая. Запятая – единственный оператор, приоритет которого ниже присваивания. В выражении a = (5,6) для явного задания приоритета использованы скобки, иначе оператор '=' выполнился бы до запятой ',', получилось бы (a=5), 6.</p>
      </section>
      <section>
        <h4>Проверка на число и неЧисло</h4>
        <p>Проверка на число. <br> isNaN(n) преобразует аргумент к числу и возвращает true для NaN, и false для остальных.</p>
<pre>
  var n = 0 / 0;
  alert( isNaN(n) ); // true
  alert( isNaN("12") ); // false, строка преобразовалась к обычному числу 12
  /////
  var x = prompt("Введите значение", "-11.5");
  if (isNaN(x)) {
    alert( "Строка преобразовалась в NaN. Не число" );
  } else {
    alert( "Число" );
  }
</pre>
        <p class="important">Важно:</p>
        <p>Пустая строка и строка из пробельных символов преобразуются к 0, поэтому считаются числами. Если применить такую проверку не к строке, то могут быть сюрпризы, в частности isNaN посчитает числами значения false, true, null, так как они хотя и не числа, но преобразуются к ним.</p>
<pre>
  alert( isNaN(null) ); //  false - не NaN, т.е. "число"
  alert( isNaN("\n  \n") ); //  false - не NaN, т.е. "число"
</pre>
        <p>Проверка на неЧисло. <br> isFinite(n) – true для числа, false для (NaN, Infinity, -Infinity, пустая строка). - преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity</p>
<pre>
  alert( isFinite(1) ); // true
  alert( isFinite(Infinity) ); // false
  alert( isFinite(NaN) ); // false
</pre>
        <p>isNumeric – специальная функция. Точная проверка на число, которая не считает числом строку из пробелов, логические и специальные значения, а также отсекает Infinity.</p>
<pre>
  function isNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }            
</pre>
        <ul>
          <li>- Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не Infinity/-Infinity/NaN.</li>
          <li>Таким образом, правая часть отсеет заведомо не-числа, но оставит такие значения как true/false/null и пустую строку '', так как они корректно преобразуются в числа.</li>
          <li>Для их проверки нужна левая часть. Вызов parseFloat(true/false/null/'') вернёт NaN для этих значений.</li>
          <li>Так устроена функция parseFloat: она преобразует аргумент к строке, то есть true/false/null становятся "true"/"false"/"null", а затем считывает из неё число, при этом пустая строка даёт NaN.</li>
        </ul>
      </section>
      <section>
        <h4>Преобразования</h4>
        <p><b>A. Строковое:</b> String(value) – в строковом контексте или при сложении со строкой. Работает очевидным образом.</p>
        <p>1. String(someValue)</p>
        <p>2. Для явного преобразования применяется и оператор "+", у которого один из аргументов строка. В этом случае он приводит к строке и другой аргумент, например:</p>
<pre>
  alert( true + "test" ); // "truetest"
  alert( "123" + undefined ); // "123undefined"            
</pre>
        <p>3. число.toString() и toString(основание системы) - converts a number to a string. При помощи такого кодирования можно «укоротить» длинный цифровой идентификатор, например чтобы выдать его в качестве URL.</p>
<pre>
  var number = 1;
  console.log(number); 		// Выведет число: 1 (number)
  console.log(number.toString()); 	// Выведет строку: "1" (string)
  var n = 4;
  alert( n.toString(2) ); // 100
  var n = 1234567890;
  alert( n.toString(36) ); // kf12oi 
  var n = 255;
  alert( n.toString(16) ); // ff            
</pre>
        <p><b>B. Численное:</b></p>
        <p>1. Number(val)</p>
        <p>2. Строгое преобразование к числу используя + .Если строка не является в точности числом, то результат будет NaN. Единственное исключение – пробельные символы в начале и в конце строки, которые игнорируются:</p>
<pre>
  alert( +"12test" ); // NaN
  alert( +"  -12" ); // -12
  alert( +" \n34  \n" ); // 34, перевод строки \n является пробельным символом
  alert( +"" ); // 0, пустая строка становится нулем
  alert( +"1 2" ); // NaN, пробел посередине числа – ошибка
  var a = +"123"; // 123
  var a = Number("123"); // 123, тот же эффект            
</pre>
        <p>3. Мягкое преобразование: parseInt и parseFloat – преобразует посимвольно пока может. В мире HTML/CSS многие значения не являются в точности числами. Например метрики CSS: 10pt или -12px. Оператор '+' для таких значений возвратит NaN:  alert(+"12px") // NaN. Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно. При возникновении ошибки возвращается число, которое получилось. Функция parseInt читает из строки целое число, а parseFloat – дробное. существуют ситуации, когда При ошибке на первом же символе parseInt/parseFloat возвращают NaN.</p>
<pre>
  alert( parseInt('12px') ) // 12, ошибка на символе 'p'
  alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке
  alert( parseInt('a123') ); // NaN
</pre>
        <p>Функция parseInt также позволяет указать систему счисления, то есть считывать числа, заданные в шестнадцатиричной и других системах счисления. Обратите внимание, что у команды два аргумента: - строка, которую мы пытаемся превратить в число; - основание системы счисления, в которую мы переводим число.</p>
<pre>
  alert( parseInt('FF', 16) ); // 255
</pre>
        <p>В JavaScript можно записывать числа не только в десятичной, но и в шестнадцатеричной системе счисления и в других. Если математическая операция не может быть совершена, то возвращается специальное значение NaN. Пустая строка преобразуется в ноль.</p>
<pre>
  alert( 0xFF ); // 255 в шестнадцатиричной системе, всегда добавляем 0x
</pre>
        <p>C. Логическое: Boolean(value) – в логическом контексте, можно также сделать двойным НЕ: !!value.</p>
<pre>
  !! ‘о’ === false;
  !! 1 === true;
</pre>
      </section>
      <section>
        <h4>Логические операторы математической (булевой) логики: &&, || и !</h4>
<pre>
  var conditionOne = true;
  var conditionTwo = true;
  var conditionThree = false;
  var conditionFour = true;
  if (conditionOne && conditionTwo) {
  // код выполнится
  }
  if (conditionThree || conditionFour) {
  // код тоже выполнится
  }
</pre>
        <p>Оператор && или «логическое И» возвращает true только в том случае, если оба условия, слева и справа от него, возвращают true. Оператор || или «логическое ИЛИ» возвращает true если любое из условий слева или справа от него, возвращают true. || запинается на «правде». && запинается на «лжи», || - на правде Приоритет у && больше, чем у ||</p>
        <p>Логическое отрицание.Чтобы создать проверки с отрицанием используют унарный (одноместный) логический оператор !. Пример:</p>
<pre>
  var condition = false;
  if (!condition) {
    // код выполнится
  }
  var conditionOne = true;
  var conditionTwo = true;
  var conditionThree = false;
  if (conditionOne && conditionTwo && !conditionThree) {
    // код выполнится
  }
</pre>
      </section>
    </section>
    

    <section class="content-section" id="loops">
      <h3>Циклы</h3>
      <section>
        <h4>Рекурсия</h4>
<pre>
  var washNextItem = function(itemsLeft) {
    itemsLeft --;
    console.log('Осталось ' + itemsLeft);
    if (itemsLeft > 0) {
      washNextItem(iemLeft);
    }
  }
  washNextItem(10);              
</pre>
      </section>
      <section>
        <h4>For Loop</h4>
<pre>
  // Переменная хранит нужное количество копий
  var page = 7;
  var count = 5;
  // можно без цикла:
  if (count === 5) {
    keks.print(page);
    keks.print(page);
    keks.print(page); 
    keks.print(page);
    keks.print(page);
  }
  // но лучше с ним
  for (var i = 0; i &lt; count; i = i + 1) { 
    keks.print(page); // повторяющиеся команды или «тело цикла» - команда
  }
  //       1       2      4
  for (var i = 0; i &lt; 10; i ++) {
      console.log([…]);        //  3
  }              
</pre>
        <p>Смысл каждой части в скобках следующий такой:</p>
        <p>1. Первая часть — подготовительная. Команда запускаются один раз перед началом работы цикла,  задаётся исходное значение для переменной-счётчика. Обратите внимание, что в цикле мы создаём переменную-счётчик с помощью var, как в случае с любой другой переменной. Традиционно такая переменная называется i (от слова index), но у неё может быть любое другое название (day, page etc.).</p>
        <p>2. Вторая часть — проверочная. Она содержит условие и запускается перед каждым новым витком цикла. Условие здесь работает по знакомому вам алгоритму. Если условие возвращает true, цикл делает ещё один виток, иначе цикл завершает свою работу. </p>
        <p>4. Тело цикла - необходимый к выполнению код</p>
        <p>3. Третья часть — дополняющая, по-научному она называется «законом изменения». Код третьей части запускается после каждого витка цикла. То есть после того, как выполнится код из тела цикла. Обычно там изменяется переменная-счётчик.</p>   
<pre>
  //Начало  → Условие (true) → Выражение → Шаг
  //	      Условие (false) → X
  // «Делать до тех пор как [true]».

  // Еще примеры:
  // Пять копий одной страницы
  var page = 7;
  var count = 5;
  for (var i = 0; i &lt; count; i = i + 1) {
    console.log(page);  
  }
  // Печать страниц с первой по пятую
  var totalPages = 5;
  for (var page = 1; page &lt;= totalPages; page = page + 1) {
    console.log(page);
  }
  // Печать страниц в обратном порядке
  var totalPages = 5;
  for (var page = totalPages; page > 0; page = page - 1) {
    console.log(page);
  }
</pre>
        <p>Можно убрать начало (1). <br> Можно убрать и шаг(2). <br> А можно и вообще убрать всё, получив бесконечный цикл(3).
<pre>
  // 1
    var i = 0;
    for (; i &lt; 3; i++) {    // тоже что и for (i = 0; i &lt; 3; i++)
      alert( i ); // 0, 1, 2
    }
  // 2 -- цикл превратился в аналог while (i &lt; 3) 
    var i = 0;
    for (; i &lt; 3;) {
      alert( i );
      // 
    }
  // 3
    for (;;) {
      // будет выполняться вечно
    }
</pre>
      </section>
      <section>
        <h4>Инкременты и декременты</h4>
<pre>
  // Инкремент: i++ аналог i = i + i
  Декремент: i-- аналог i = i - i
  Комбо: i+=2 аналог i = i + 2
</pre>
        <p>Комбинировать можно не только сложение, но и остальные математические операции: вычитание -=, умножение *=, деление /= и нахождение остатка %=. Например, i *= 10 будет аналогично i = i * 10. Постфиксная форма i++ отличается от префиксной ++i тем, что возвращает старое значение, бывшее до увеличения.  Инкремент/декремент можно применить только к переменной. Код 5++ даст ошибку.</p>
      </section>
      <section>
        <h4>накопление в цикле</h4>
        <p>Нужно завести перед циклом ещё одну переменную, которая будет хранить информацию</p>
<pre>
  var sum = 0;
    for (var i = 1; i &lt;= 5; i++) {
    sum += 2;
    console.log(sum);
  }
  /*
  Программа выведет:
  LOG: 2 (number)
  LOG: 4 (number)
  LOG: 6 (number)
  LOG: 8 (number)
  LOG: 10 (number)
  Цикл выполняет операцию столько раз, сколько это предусмотрено самим циклом.
  */              
</pre>
      </section>
      <section>
        <h4>Проверки в циклах (if в for)</h4>
        <p>Например, можно проверять значение счётчика, и если оно больше двух, прибавлять к сумме 3, а не 2.</p>
<pre>
  var sum = 0;
  for (var i = 1; i &lt;= 5; i++) {
    if (i > 2) {
      sum += 3;
    } else {
      sum += 2;
    }
    console.log(sum);
  }
</pre>
      </section>
      <section>
        <h4>While Loop</h4>
<pre>
  while (условие) {
    действия
  }
</pre>
        <p>Действия, указанные в цикле, будут выполняться снова и снова, пока условие не вернёт false.</p>
<pre> 
  i = 10;
  while(i > 0) {
    console.log(i);
    i--;
  }
</pre>
      </section>
      <section>
        <h4>break / continue</h4>
        <p>помнить: нельзя использовать справа от оператора „?“. break прерывает исполнение цикла. Внутри while команда continue «перематывает» программу сразу к началу следующей итерации. Внутри for команда continue «перематывает» программу к дополнительной части текущей итерации, после выполнения которой начинается следующая итерация цикла.</p>
        <p>Метки для break/continue. Бывает нужно выйти одновременно из нескольких уровней цикла. Например, внутри цикла по i находится цикл по j, и при выполнении некоторого условия мы бы хотели выйти из обоих циклов сразу:</p>
<pre>
  outer: for (var i = 0; i &lt; 3; i++) {
    for (var j = 0; j &lt; 3; j++) {
    var input = prompt('Значение в координатах '+i+','+j, '');
        // если отмена ввода или пустая строка -
        // завершить оба цикла
        if (!input) break outer; // (*)
      }
    }
    alert('Готово!');              
</pre>
      </section>
      <section>
        <h4>Другие виды циклов</h4>
<pre>
  // 1-- for - обычный цикл, ничего не возвращает, производит действие в теле 
  // 2-- while - пока условие истинно. do...while - то же самое. 

  // for...of - для перебора данных, например, значений массива. Он также работает с большинством массивоподобных объектов, вроде списковNodeList в DOM.
  // Работает с break, continue и return.

  // 3-- <b>array.forEach</b> - метод циклов для перебора, ничего не возвращает, тот же for
  var names = ['HTML', 'CSS', 'JavaScript'];
  var arr = [];
  names.forEach(function(item, i, array) {
    arr.push(' Длина '+ item + ': ' + item.length);
    console.log('Элемент ' + item + ', индекс ' + i);
  });
  console.log('array.forEach --> ' + arr);
  // Но не работает с break, continue и return.
  // Еще пример: 
  let products = [
    { name: 'Running shoes', price: 75 },
    { name: 'Golf shoes',    price: 85 },
    { name: 'Dress shoes',   price: 95 },
    { name: 'Walking shoes', price: 65 },
    { name: 'Sandals',       price: 55 }
  ];
  products.forEach((product, index) => {
    console.log(product);
  });
  // и еще
  var students = ['Eugene', 'Julia', 'Michael'];
    students.forEach(function(student) {
  });

  // <b>for loop vs forEach loop</b>
  for (let i = 0; i &lt; products.length; i++) {
    let product = products[i];
    console.log(product);
    for (let j = 0; j &lt; product.sizes.length; j++) {
      let size = product.sizes[j];
      console.log(size);
    }
  }
  products.forEach((product) => {
    product.sizes.forEach((size) => {
      console.log(size);
    });
  });
  // when you want to break out of a loop early, use 'for'. If you used forEach(), it would iterate over every single product resulting in unnecessary iterations
  for (let i = 0; i &lt; products.length; i++) {
    if (matchesSomeCriteria(products[i])) {
      doSomething();
      break;
    }
  } 

  /* 4-- метод <b>arr.map(callback[, thisArg])</b> метод массива используется для трансформации массива. Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr. Позволяет создать новый массив, основанный на каким-то образом обработанных значениях другого массива.*/
  var names = ['HTML', 'CSS', 'JavaScript'];
  var nameLengths2 = names.map(function(name) {
    return name.length;
  });
  console.log('array.map --> ' + nameLengths2); // вернет массив из длины элементов
  //  или так:
  const numbers = [2, 3, 4, 5];
  const dollars = numbers.map( number => '$' + number);
  // Вот как будет выглядеть массив dollars: ['$2', '$3', '$4', '$5']

  /* 5-- <b>arr.filter</b> - фильтрация массива - cоздаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) / которые соответствуют заданному условию.
  возвратит true. */
  var someArr = [10,20,30,40,50,60,70,80,90];
  var newArr = someArr.filter(function(item) {
    return item > 50;
  });
  console.log('arr.filter --> ' + newArr);
  console.log('_____');
  // или так:
  const studentsAge = [17, 16, 18, 19, 21, 17];
  const ableToDrink = studentsAge.filter( age => age > 18 );
  // Массив ableToDrink будет содержать два значения: [19, 21]

  /* 6-- <b>every/some</b> - возвращает true, если вызов callback вернёт true для каждого/какого-нибудь элемента arr.*/
  var arr = [1, -1, 2, -2, 3];
  function isPositive(number) {
    return number > 0;
  }
  console.log(arr.every(isPositive)); // false, не все положительные
  console.log(arr.some(isPositive)); // true, есть хоть одно положительное

  /* 7-- <b>reduce/reduceRight</b> – для прохода по массиву с вычислением значения. */
  var numbers = [1,2,3,4,5,6,7,8,9,0];
  // var sum = 0;
  // for (var i = 0; i &lt; numbers.length; i ++) {
  //   sum += numbers[i];
  // }
  // console.log(sum);
  // console.log('_____');
  var result = numbers.reduce(function(sum, current) {
    console.log('всего: ' + (sum + current))
    return sum + current;
  }, 0); // можно и без нуля, перебор стартует со второго элемента
  console.log(result);

  const numbers = [5, 10, 15];
  const total = numbers.reduce( (accumulator, currentValue) => accumulator + currentValue);
  // в константу total будет записано число 30

</pre>
      </section>
    </section>


    <section class="content-section" id="arrays">
      <h3>Массивы</h3>

      <section>
        <h4>Общее</h4>
        <p>Массив — это тип данных, который представляет собой список элементов, у каждого из которых есть свой порядковый номер. Массивы создаются с помощью квадратных скобок. Внутри скобок через запятую перечисляются все значения, которые должен содержать массив. При создании массив, как любое значение, можно записать в переменную. В массиве можно хранить любые данные: строки, булевы значения, числа и даже другие массивы. Одно из применений массива – это очередь. В классическом программировании так называют упорядоченную коллекцию элементов, такую что элементы добавляются в конец, а обрабатываются – с начала. Очень близка к очереди еще одна структура данных: стек. Это такая коллекция элементов, в которой новые элементы добавляются в конец и берутся с конца. Например, стеком является колода карт, в которую новые карты кладутся сверху, и берутся – тоже сверху.</p>
<pre>
  var numbers = [1, 2, 3, 4, 5]; // массив
</pre>
        <p>Чтобы получить <b>элемент массива</b>, нужно в квадратных скобках указать порядковый номер или индекс этого элемента. Нумерация элементов в массиве начинается с нуля: первый элемент массива идёт под номером ноль, второй — под номером один, третий — два и так далее. В скобках можно записывать что угодно, главное чтобы получалось число.</p>
<pre>
  var numbers = [1, 2, 3, 4, 5];
  console.log(numbers[1]); // Выведет в консоль 2
  var some = 4
  console.log(numbers[some]); // выведет в консоль 5            
</pre>
        <p><b>Длина массива</b>. Массивы умеют рассказывать о своей длине. Для этого используется команда [].length:</p>
<pre>
  var numbers = [1, 2, 3, 4];
  console.log(numbers.length);
  // Выведет в консоль 4            
</pre>
        <p>С помощью обращения к length можно получить <b>последний элемент массива</b>, даже если вы не знаете, сколько элементов в нём хранится. Допустим, в этом большом массиве 100 элементов. Его длина будет равна 100. Индекс последнего, сотого, элемента будет равен 99 потому что нумерация в массивах начинается с нуля. Поэтому индекс последнего элемента вычисляется вычитанием единицы из длины. Длина (length) – не количество элементов массива, а последний индекс + 1.</p>
<pre>
  someBigArray[someBigArray.length - 1]; // последний элемент массива

  // Используем length для укорачивания массива
  var arr = [1, 2, 3, 4, 5];
  arr.length = 2; // укоротить до 2 элементов
  alert( arr ); // [1, 2]
  arr.length = 5; // вернуть length обратно, как было
  alert( arr[3] ); // undefined: значения не вернулись
</pre>
      </section>
      <section>
        <h4>Циклы и массивы</h4>
        <p>Начальный индекс у массива мы знаем. Он равен нулю. Индексы в массиве возрастают на единицу. Использовать переменную в качестве индекса можно. Получается, что мы можем задать переменной нулевое значение, а затем использовать её в цикле для доступа к элементам массива, наращивая в каждой итерации на единицу. Переменная цикла будет использоваться как индекс элементов массива. Поэтому зададим ей нулевое значение и будем увеличивать в каждой итерации на единицу, пока её значение не станет равным индексу последнего элемента.</p>
<pre>
  for (var i = 0; i &lt; someArray.length; i ++) {
    console.log(someArray[i]) // Выводим в консоль элементы массива, пока 
  }
  // или так:
  for (var i = 0; i &lt;= someArray.length - 1; i ++) {
    console.log(someArray[i]) // Выводим в консоль элементы массива, пока 
  }
</pre>
      </section>
      <section>
        <h4>Запись в массив</h4>
        <p>Запись в массив происходит так же, как и чтение — через обращение к элементу с помощью квадратных скобок. Обратите внимание, что если в массиве нет элемента под тем номером, под которым мы записываем, то этот элемент будет создан. До выполнения кода в массиве не было ни нулевого, ни первого элементов, но после того, как мы записали значения в эти позиции, элементы добавились в массив.</p>
<pre>
  var numbers = [];
  var index = 1;
  numbers[0] = 1;
  numbers[index] = 2;
  // Выведет [1,2]
  console.log(numbers);            
</pre>
      </section>
      <section>
        <h4>Многомерные массивы</h4>
        <p>Массивы в JavaScript могут содержать в качестве элементов другие массивы. Это можно использовать для создания многомерных массивов, например матриц:</p>
<pre>
  var arr = [
    [1,2,3],
    [4,5,6],
    [7,8,9],
    [[10,11,12], 13, 14]
  ];
  arr[3]; // equals [[10,11,12], 13, 14]
  arr[3][0]; // equals [10,11,12]
  arr[3][0][1]; // equals 11          
</pre>
        <p class="important">Важно:</p>
        <p>Не используйте for..in (рассматривается ниже) для массивов. Цикл for..in выведет все свойства объекта, а не только цифровые (да, у массива есть и другие свойства - об этом ниже). Цикл for выполняется в 10-100 раз быстрее.</p>
      </section>        
      <section>
        <h4>arr.indexOf() & arr.lastIndexOf()</h4>
        <p>Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или -1, если его нет. Для поиска используется строгое сравнение ===. Можем найти строку из одного символа, если обратиться ко всей строке, используя индекс переменная[0]:</p>
<pre>
  var string = 'Меня зовут Кекс'; // Записываем строку в переменную
  console.log(string[5]); // Ищем шестой элемент в строке → Вернёт 'з'
  string.indexOf('Кекс') // Ищем, есть ли в строке подстрока 'Кекс' → Вернёт 11          
  
  var numbers = [2, 5, 9, 2];
  numbers.lastIndexOf(2);     // 3
</pre>
        <p>По синтаксису эти методы аналогичны методу indexOf() / lastIndexOf() для строк.</p>
      </section>
      <section>
        <h4>Быстрый поиск по массиву: это интересно</h4>
          <img src="images/Arrays__array-to-object.png" alt="array-to-object">
<pre>
  var some = {};
  var items = ['for', 'a', 'div'];
  for (var i = 0; i &lt; items.length; i ++) {
    var key = items[i];
    some[items[i]] = true;
  }
  if(some['dip']) {
    console.log('YES');
  } else {
    console.log('NO');
  }              
</pre>
      </section>
      <section>
        <h4>Псевдомассивы</h4>
        <p>Псевдомассив — это объект, который структурно похож на массив. То есть у него есть числовые свойства (индексы) и свойство length. Их мы получаем, к примеру, когда ищем несколько селекторов сразу (поиск по HTML описан ниже). Важно то, что псевдомассивы не отвечают на методы массивов, но псевдомассив можно превратить в нормальный массив при помощи методов slice или Array.from() (описаны ниже).</p>
<pre>
  var elems = document.documentElement.childNodes;
  elems = Array.prototype.slice.call(elems); // теперь elems - массив
</pre>
      </section>
      <section class="">
        <h4>Методы массивов</h4>
<pre>

  var someArray = [1,'a', 'someNoun', 6894, [0,2,4,6]];
  // большинство методов возвращают полученое значение

  // <b>array.push(element)</b> - добавление элементов в конец массива 
  // <b>array.pop()</b> - удаление последнего элемента
  /* Методы push и unshift могут добавлять сразу по несколько элементов, указывать их через запятую. Методы push/pop выполняются быстро, а shift/unshift – медленно. Так как все элементы находятся в своих ячейках, просто удалить элемент с номером 0 недостаточно. Нужно еще и переместить остальные элементы на их новые индексы.
  */
  // <b>array.shift()</b> - удаление первого элемента массива
  // <b>array.unshift(element)</b> - добавление первого элемента в массив 

  someArray.push('My name is Eugene'); //  вернет [1,'a', 'someNoun', 6894, [0,2,4,6], 'My name is Eugene']
  someArray.pop() // вернет [1,'a', 'someNoun', 6894, [0,2,4,6]]
  someArray.shift() // вернет ['a', 'someNoun', 6894, [0,2,4,6]]
  someArray.unshift('blablabla') // вернет ['blablabla', 'a', 'someNoun', 6894, [0,2,4,6]]

  // удаление и добавление в середину массива
  // <b>array.splice(index [, deleteCount, elem1,...,elemN])</b> - Удалить deleteCount элементов, начиная с номера index, а затем вставить elem1, ..., elemN на их место. , можно с отрицательным индексом .Возвращает массив из удалённых элементов.
  var someArray = [1,'a', 'someNoun', 6894, [0,2,4,6]];
  console.log(someArray.splice(-1)); // вырежет последний элемент и вернет его
  var someArray = [1,'a', 'someNoun', 6894, [0,2,4,6]];
  console.log(someArray.splice(1,2)); // вырежет два предпоследних элемента и вернет его, останется [1, 6894, [0,2,4,6]];
  var someArray = [1,'a', 'someNoun', 6894, [0,2,4,6]];
  someArray.splice(2,2, 'My', 'name', 'is', 'Eugene');
  console.log(someArray); // вернет [1,'a', 'My', 'name', 'is', 'Eugene', [0,2,4,6]];

  // <b>array.join(разделитель)</b> - массив в строку
  someArray.join('') // вернет "1asomeNoun68940,2,4,6" 
  someArray.join() // вернет "1asomeNoun68940,2,4,6"
  someArray.join(' ') вернет "1 a someNoun 6894 0,2,4,6"
  someArray('-') // вернет "1-a-someNoun-6894-0,2,4,6"

  // <b>array.slice(begin, end)</b> - копирование (без end - до конца), возвращает скопированное
  var items = [1,2,3,4,5,6,7,8,9],
      arrleng = items.length,
      itemsCopy = [],
      itemsCopy2 = [];
  // плохо
  for (var i = 0; i &lt; arrleng; i++) {
    itemsCopy[i] = items[i];
  }
  console.log(itemsCopy);
  // хорошо
  itemsCopy2 = items.slice();
  console.log(itemsCopy2);
  // <b>array.reverse()</b> - меняет порядок элементов
  // <b>array.concat(value1, value2, … valueN)</b> - копия массива + новые элементы. Если аргумент concat – массив, то concat добавляет элементы из него.
  var array = [1,'a', 'someNoun', 6894, [0,2,4,6]];
  console.log(array.slice(3)); // вернет [6894, [0,2,4,6]]
  array.reverse(); // вернет массив наоборот
  var newArray = array.concat(1,2);
  console.log(newArray);
  // <b>Array.from(someString)</b>  - cтатический метод array.from() позволяет создавать массивы на основании других массивов или строк. */
  var array = 'abcdefghijklmn';
  console.log(Array.from(array)); // вернет ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n"]
  const newArray = Array.from('hello');
  //массив newArray будет иметь вид ['h', 'e', 'l', 'l', 'o']
  const doubledValues = Array.from([2, 4, 6], number => number * 2);
  // в массив doubleValues будут записаны следующие данные: [4, 8, 12]

  // array.includes() - позволяет узнать, содержит ли массив заданное значение, проверяет на наличие в массиве заданного при его вызове значения.
  // Проверим, имеется ли в массиве строковой элемент waldo:
  const names = ['sophie', 'george', 'waldo', 'stephen', 'henry'];
  const includesWaldo = names.includes('waldo');   // includesWaldo получит значение true
  
  // The .<b>array.fill()</b> method fills (modifies) all the elements of an array from a start index (default zero) to an end index (default array length) with a static value. It returns the modified array.
  var array1 = [1, 2, 3, 4];
  console.log(array1.fill(0, 2, 4)); // fill with 0 from pos.2 until pos.4, expected output: [1, 2, 0, 0]
  console.log(array1.fill(5, 1)); // fill with 5 from pos.1, expected output: [1, 5, 5, 5]
  console.log(array1.fill(6)); // expected output: [6, 6, 6, 6]
  
  // The <b>array.find()</b> method returns the value of the first element in the array that satisfies the provided testing function. Otherwise undefined is returned.
  var array1 = [5, 12, 8, 130, 44];
  var found = array1.find(function(element) {
    return element > 10;
  });
  console.log(found); // expected output: 12

  //The <b>array.flat()</b> method creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.
  var arr1 = [1, 2, [3, 4]]; 
  arr1.flat(); // [1, 2, 3, 4] 
  var arr2 = [1, 2, [3, 4, [5, 6]]]; 
  arr2.flat(); // [1, 2, 3, 4, [5, 6]] 
  var arr3 = [1, 2, [3, 4, [5, 6]]]; 
  arr3.flat(2); // [1, 2, 3, 4, 5, 6]



</pre>
      </section>
      <section>
        <h4>Методы сортировки</h4>
<pre>
  // <b>sort(fn)</b> – встроенная быстрая сортировка
  var arr = [ 1, 2, 15 ];
  arr.sort();
  alert(arr); // 1, 15, 2

  /* Порядок стал 1, 15, 2 потому что по умолчанию sort сортирует, преобразуя элементы к строке, а  "2" > "15".
  Для указания своего порядка сортировки в метод arr.sort(fn) нужно передать функцию fn от двух элементов, которая умеет сравнивать их.
  Внутренний алгоритм функции сортировки умеет сортировать любые массивы – апельсинов, яблок, пользователей, и тех и других и третьих – чего угодно. Но для этого ему нужно знать, как их сравнивать. Эту роль и выполняет fn. Если эту функцию не указать, то элементы сортируются как строки. Например, укажем эту функцию явно, отсортируем элементы массива как числа: */

  var arr = [ 1, 13, 15, 8, 9, 2, 13];
  function compareNumeric(a, b) {
    return a - b;
  }
  /* или так:
  function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a &lt; b) return -1;
  }
  */
  arr.sort(compareNumeric); // вернёт [1, 2, 8, 9, 13, 13, 15]

  /* В методе sort, внутри самого интерпретатора JavaScript, реализован универсальный алгоритм сортировки. Как правило, это ««быстрая сортировка»», дополнительно оптимизированная для небольших массивов. Он решает, какие пары элементов и когда сравнивать, чтобы отсортировать побыстрее. Мы даём ему функцию – способ сравнения, дальше он вызывает её сам.
  Кстати, те значения, с которыми sort вызывает функцию сравнения, можно увидеть, если вставить в неё alert: */
  [1, -2, 15, 2, 0, 8].sort(function(a, b) {
    alert( a + " &lt;> " + b );
  });


  var myArray = [2, 3, 5, 0.5, 19, 6, 9, 11,148,11,8];
  console.log('Было: [' + myArray + ']');

  // <b>Пузырьковая сортировка / Сортировка пузырьком / Bubble Sort</b>: по очереди меняем местами сравниваемые элементы.

  function bubbleSort (arr) {
    var swaped = false; // флаг, в случае если перестановок не было, список отсортирован, значение флага изменяется (ниже) и цикл завершае работу
    var counter = 0; // УДАЛИТЬ - для обучения: счётчик для подсчёта итераций
    for (var i = 0; i &lt; arr.length - 1; i ++) { // для всех, кроме последнего элемента
      for (var j = 0; j &lt; arr.length; j ++) {
        if (arr[j] &lt; arr[j + 1]) { // или все внутри одной строчкой: [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // если элемент идующий за текущим больше его, меняем их местами, для обратной сортировки поменять знак
          var swap = arr[j];  
          arr[j] = arr[j + 1]; 
          arr[j + 1] = swap;
          swaped = true;
        }
        counter ++; // УДАЛИТЬ
      }
      if (!swaped) { break; } // для флага
    }
    console.log(counter); // УДАЛИТЬ
    return arr;
  }
  console.log('Получили от bubbleSort: [' + bubbleSort(myArray) + ']');

  // <b>Сортировка выбором / Selection Sort</b>: сравниваю каждое число с минимальным или максимальным элементом
  function selectionSort(arr) {  
    var counter = 0; // УДАЛИТЬ - для обучения: количество итераций
    for (var i = 0; i &lt; arr.length - 1; i ++){ // Выполняется для каждого элемента массива, кроме последнего.
      for (var j = i + 1; j &lt; arr.length; j ++){ // а для всех последующих элементов
        if (arr[i] > arr[j]) { // если число меньше минимального, меняем их местами, для обратной сортировки поменять знак
          var max = arr[j]; 
          arr[j] = arr[i]; 
          arr[i] = max; 
      }
      }
    }
    return arr;
  }
  console.log('Получили от selectionSort: [' + bubbleSort(myArray) + ']');
  
  // <b>Сортировка вставками / Insertion Sort</b>: перемещаю элементы пока arr[index - 1] > arr[index]
  
  function insertionSort(arr) {           
    for (var i = 1; i &lt; arr.length; i ++) { 
      var current = arr[i];  // переменная для текущего элемента, используется для обмена значениями 
      var index = i;   // индекс текущего элемента
      while (index > 0 && arr[index - 1] > current) { // перемещаем текущий элемент покуда он не станет меньше чем элемент слева от него (arr[index - 1] > current) или до тех пор пока он не станет первым в массиве (index > 0 - пока первый элемент не первый - если второй, то будет еще одна итерация)
        arr[index] = arr[index - 1];  // текущий элемент равен предыдущему элементу
        index --; // понижаем индекс для повторения цикла (продолжаем двигаться по массиву влево, если раньше сравнивали 4 и 5 элементы, то теперь будем 3 и 4)
      }
      arr[index] = current; // заканчиваем менять значения местами. Вставляем текущий элемент в отсортированную часть списка. Мы можем вставить current в положение index потому что выше мы присвоили следующему индексу значение, которое здесь было раньше. 
    }                    
    return arr;
  }
  console.log('Получили от insertionSort: [' + insertionSort(myArray) + ']');

  
  https://proglib.io/p/sort-algorithms/<br>
  // <b class="danger">Сортировка слиянием / Merge Sort</b> - там где больше 50 элементов, но ест больше оперативной памяти
  <b style="color: red; overflow-wrap: break-word;">
    https://medium.com/@alivander/
    %D1%81%D0%BE%D1%80%D1%82%D0%B8%D
    1%80%D0%BE%D0%B2%D0%BA%D0%B0
    -%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC
    -javascript-1c0b0e8ff737
  https://medium.com/@dimko1/%D0%B0%D0%BB%D0%B3%D0%BE%D1
  %80%D0%B8%D1%82%D0%BC%D1%8B
  -%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%
  80%D0%BE%D0%B2%D0%BA%D0%B8-merge-sort-9ca26ac4764a</b>
  // <b class="danger">Быстрая сортировка</b>
  <b style="color: red">https://www.youtube.com/watch?v=4s-aG6yGGLU</b>
  // <b class="danger">Shell sort</b>

  // <b class="danger">Tim sort</b>
</pre>
      </section>
    </section>


    <section class="content-section" id="functions">
      <h3>Функции</h3>
      <section>
        <h4>Общее</h4>
        <p>Чтобы не повторять один и тот же код во многих местах, придуманы функции. Функции являются основными «строительными блоками» программы. Пример объявления функции:</p>
<pre>
  var functionName = function () {
    // Действия, которые выполняет функция или «тело функции»
  };        
</pre>
        <p>Вначале идет ключевое слово function, после него имя функции, затем список параметров в скобках (в примере выше он пустой) и тело функции – код, который выполняется при её вызове.Объявленная функция доступна по имени, например:</p>
<pre>
  function showMessage() {
    alert( 'Привет всем присутствующим!' );
  }
  showMessage(); // скобки обязательны, иначе может вывести код функции             
</pre>
      </section>
      <section>
        <h4>Название функции, Function Declaration vs Function Expression</h4>
        <p>общепринятое правило именования — название функции должно содержать глагол (toShow, getAge, calcSomething, createForm, checkPermission).</p>
<pre>
  // Function Declaration
  function sum(a, b) {
    return a + b;
  }                  // главное не мешать declaration и expression !!!
  // Function Expression
  var sum = function(a, b) {
    return a + b;
  }            
</pre>
        <p>Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода (их можно вызвать до объявления). Также переменные в Function Declaration при use strict видны только внутри блока, в котором объявлены. Если нет явной причины использовать Function Expression – предпочитайте Function Declaration. Сравните по читаемости: </p>
<pre>
  // Function Expression
  var f = function() { ... }
  // Function Declaration
  function f() { ... }
</pre>
        <p>Одна функция – одно действие. Функция должна делать только то, что явно подразумевается её названием. И это должно быть одно действие. Если оно сложное и подразумевает действия, имеет смысл выделить их в отдельные функции. Например, функция проверки данных (скажем, "validate") не должна показывать сообщение об ошибке. Её действие – проверить.</p>
      </section>
      <section>
        <h4>Параметры фукнции</h4>
        <p>— значения, с помощью которых можно настраивать функции. Так мы можем узнать результат работы функции для разных случаев. С аргументами (пареметры – те же аргументы, но так они называются, когда задаются первый раз) есть один нюанс — передавать их надо в том же порядке, в котором объявлены параметры функции.</p>
<pre>
  var showTime = function (hours, minutes) {
    console.log('Текущее время: ' + hours + ':' + minutes);
  };
  showTime(3, 15);   // Выведет 'Текущее время: 3:15'
  showTime(6, 20);   // Выведет 'Текущее время: 16:20'            
</pre>
        <p class="important">Важно:</p> 
        <p>если у функции указан параметр, но аргумент не передан, то значение параметра в теле функции будет undefined — то есть ничего.</p>
      </section>
      <section>
        <h4>Локальные переменные, область видимость функций и передача функциям переменных</h4>
        <p>Функция может содержать локальные переменные, объявленные через var. Такие переменные видны только внутри функции.</p>
<pre>
  function showMessage() {
    var message = 'Привет, я - Вася!'; // локальная переменная
    alert( message );
  }
  showMessage(); // 'Привет, я - Вася!'
  alert( message ); // &lt;-- будет ошибка, т.к. переменная видна только внутри      
</pre>
        <p>Переменные, объявленные на уровне всего скрипта, называют «глобальными переменными». Обратите внимание: все манипуляции над переменными внутри функций на самом деле производятся не над самими переменными а над их копией, поэтому содержимое самих переменных в результате выполнения функций не изменяется.</p>
        <p class="important">Важно:</p>
        <p>Блоки if/else, switch, for, while, do..while не влияют на область видимости переменных.</p>
<pre>
  /* Зададим функцию, которая прибавляет к переданной переменной 10 и выводит результат на страницу */
  function plus(a){
    a=a+10;
    document.write('Вывод функции: ' + a);
  }
  var a=25;
  document.write('Значение переменной до вызова функции: '+ a);
  // Вызовем функцию передав ей в качестве аргумента переменную a
  plus(a);
  document.write('Значение переменной после вызова функции: '+ a);
</pre>
        <p>Чтобы обращаться к глобальной переменной из функции, а не ее копии используйте window.имя_переменной.</p>
<pre>
  function plus(a){
    window.a=a+10;
  }
  var a=25;
  document.write('Значение переменной до вызова функции: '+a+'<br />');
  plus(a);
  document.write('Значение переменной после вызова функции: '+a+'<br />');           
</pre>
      </section>
      <section>
        <h4>Анонимные функции</h4>
        <p>Функции, которые не содержат имени при объявлении называются анонимными. Анонимные функции в основном объявляют не для последующего их вызова из кода как обычные функции, а для передачи другим функциям в качестве параметра.</p>
<pre>
  function ask(question, yes, no) {
    if (confirm(question)) yes()
    else no();
  }
  ask(
    "Вы согласны?",
    function() { alert("Вы согласились."); },
    function() { alert("Вы отменили выполнение."); }
  );            
</pre>
        <p>Здесь функции объявлены прямо внутри вызова ask(...), даже без присвоения им имени. Функциональное выражение, которое не записывается в переменную, называют анонимной функцией. Зачем нам записывать функцию в переменную, если мы не собираемся вызывать её ещё раз? Можно просто объявить непосредственно там, где функция нужна. Такого рода код возникает естественно, он соответствует «духу» JavaScript.</p>
      </section>
      <section>
        <h4>Возвращение из функции – return blabla;</h4>
        <p>Функция может выполнить код и отдать результат операций для дальнейшей работы с этим результатом. Он подставится в то место кода, где мы вызвали функцию.</p>
<pre>
  var increaseByTwo = function (number) {
    var sum = 2 + number;
    return sum;
  };
  increaseByTwo(1); // Функция вернёт 3
  increaseByTwo(2); // Функция вернёт 4
</pre>
        <p>Когда программа доходит до строки с return, функция отдаёт результат работы и выполнение кода из тела функции останавливается, происходит выход из функции, дальнейший код функции не выполняется.</p>
        <p class="impotant">Важно:</p>
        <p>- Функция не может вернуть сразу много значений, она возвращает только один результат. <br> - Если внутри функции нет return или после return не указано, какое значение нужно вернуть, функция вернёт undefined, иными словами, ничего. Директива return может также использоваться без значения, чтобы прекратить выполнение и выйти из функции. В случае, когда функция не вернула значение или return был без аргументов, считается что она вернула undefined.</p>
        <p>... можно проверить, и если параметр не передан – присвоить ему значение «по умолчанию»:</p>
<pre>
  function showMessage(from, text) {
    if (text === undefined) {
      text = 'текст не передан';
    }
    alert( from + ": " + text );
  }
  showMessage("Маша", "Привет!"); // Маша: Привет!
  showMessage("Маша"); // Маша: текст не передан
  Или использовать оператор ||:
    function showMessage(from, text) {
    <b>text = text || 'текст не передан';</b>
    ...
  }
  </pre>
          <p>Второй способ считает, что аргумент отсутствует, если передана пустая строка, 0, или вообще любое значение, которое в логическом контексте является false.</p>
      </section>
      <section>
        <h4>Псевдомассив arguments</h4>
        <p>В JavaScript любая функция может быть вызвана с произвольным количеством аргументов:</p>
<pre>
  function go(a,b) {
    alert("a="+a+", b="+b);
  }
  go(1);     // a=1, b=undefined
  go(1,2);   // a=1, b=2
  go(1,2,3); // a=1, b=2, третий аргумент не вызовет ошибку            
</pre>
        <p>Доступ к «лишним» аргументам. Как получить значения аргументов, которых нет в списке параметров? Доступ к ним осуществляется через «псевдо-массив» arguments. Он содержит список аргументов по номерам: arguments[0], arguments[1]…, а также свойство length.</p>
<pre>
  function sayHi() {
    for (var i = 0; i &lt; arguments.length; i++) {
      alert( "Привет, " + arguments[i] );
    }
  }
  sayHi("Винни", "Пятачок"); // 'Привет, Винни', 'Привет, Пятачок'            
</pre>
        <p class="important">Важно:</p>
        <p>Аргументы отделены от локальных переменных:</p>
<pre>
  function f(x) {
    "use strict"; // для браузеров с поддержкой строгого режима
    arguments[0] = 5;
    alert( x ); // не 5, а 1! Переменная "отвязана" от arguments
  }
  f(1);            
</pre>
      </section>
      <section>
        <h4>Аргументы по умолчанию через ||.</h4>
        <p>Если функция вызвана с меньшим количеством аргументов, чем указано, то отсутствующие аргументы считаются равными undefined. Присвоить аргументу некоторое «стандартное» значение можно при помощи оператора логическое или ||.</p>
<pre>
  function showWarning(width, height, title, contents) {
    width = width || 200; // если не указана width, то width = 200
    height = height || 100; // если нет height, то height = 100
    title = title || "Предупреждение";
    //...
  }
  function showWarning(width, height, title, contents) {
    if (width === undefined) width = 200;
    if (height === undefined) height = 100;
    if (title === undefined) title = "Предупреждение";
    //...
  }            
</pre>
      </section>
      <section>
        <h4>«Именованные аргументы»</h4>
        <p>Именованные аргументы – альтернативная техника работы с аргументами, которая вообще не использует arguments. Некоторые языки программирования позволяют передать параметры как-то так: f(width=100, height=200), то есть по именам, а что не передано, тех аргументов нет. В JavaScript для этих целей используется передача аргументов в виде объекта, а в его свойствах мы передаём параметры. Получается так:</p>
<pre>
  function showWarning(options) {
    var width = options.width || 200; // по умолчанию
    var height = options.height || 100;
    var contents = options.contents || "Предупреждение";
    // ...
  }            
</pre>
        <p>Вызвать такую функцию очень легко. Достаточно передать объект аргументов, указав в нем только нужные:</p>
<pre>
  showWarning({
    contents: "Вы вызвали функцию" // и всё понятно!
  });            
</pre>
        <p>Сравним это с передачей аргументов через список:</p>
<pre>
  showWarning(null, null, "Предупреждение!");
  // мысль программиста "а что это за null, null в начале? ох, надо глядеть описание функции"
  // Именованные аргументы применяются во многих JavaScript-фреймворках.
  // Еще один бонус кроме красивой записи – возможность повторного использования объекта аргументов:
  var opts = {
    width: 400,
    height: 200,
    contents: "Текст"
  };
  showWarning(opts);
  opts.contents = "Другой текст";
  showWarning(opts); // вызвать с новым текстом, без копирования других аргументов
</pre>
        <p>Возможен и гибридный подход, при котором первый аргумент обязателен, а второй – options, который содержит всевозможные дополнительные параметры:</p>
<pre>
  function showMessage(text, options) {
    // показать сообщение text, настройки показа указаны в options
  }
</pre>
      </section>
    </section>


    <section class="content-section" id="strings">
      <h3>Строки</h3>
      <section>
        <h4>Общее</h4>
        <p>Строки создаются при помощи двойных или одинарных кавычек, различий нет между этими способами нет:</p>
<pre>
  var text = "моя строка";
  var anotherText = 'еще строка';
  var str = "012345";          
</pre>
      </section>
      <section>
        <h4>Экранирование специальных символов</h4>
        <p>Если строка в одинарных кавычках, то внутренние одинарные кавычки внутри должны быть экранированы, то есть снабжены обратным слешем \', вот так:</p>
<pre>
  var str = 'I\'m a JavaScript programmer';
  var str = "I'm a JavaScript \"programmer\" ";
  alert( str ); // I'm a JavaScript "programmer"
  var str = ' символ \\ ';
  alert( str ); // символ \

  alert( 'Привет\nМир' ); // перевод строки - выведет "Мир" на новой строке
</pre>
      </section>
      <section>
        <h4>Изменение строк</h4>
        <p>Содержимое строки в JavaScript нельзя изменять. Можно лишь создать целиком новую строку и присвоить в переменную вместо старой, например:</p>
<pre>
  var str = "строка";
  str = str[3] + str[4] + str[5];
  alert( str ); // ока            
</pre>
      </section>
      <section>
        <h4>Юникод</h4>
<pre>
  String.fromCharCode(code) // метод для получения символа по его коду:
  alert( String.fromCharCode(1072) ); // 'а' --> Возвращает символ по коду code:
  str.charCodeAt(pos) // …И метод для получения цифрового кода из символа:
  alert( "абрикос".charCodeAt(0) ); // 1072, код 'а'. Возвращает код символа на позиции pos. Отсчет позиции начинается с нуля.
</pre>
        <p>Юникод в HTML</p>
        <p>Для этого нужно написать сначала &amp;&#35;, затем код, и завершить точкой с запятой ';'. Например, символ 'а' в виде числовой ссылки: &#1072;. Если код хотят дать в 16-ричной системе счисления, то начинают с &amp;&#35;x. В юникоде есть много забавных и полезных символов, например, символ ножниц: ✂ (&#x2702;), дроби: ½ (&#xBD;) ¾ (&#xBE;) и другие. Их можно использовать вместо картинок в дизайне.</p>
      </section>
      <section>
        <h4>Методы и свойства для строк</h4>
<pre>
  // <b>Длина length</b>
  var str = "My\n"; // 3 символа. Третий - перевод строки
  alert( str.length ); // 3        
  
  // Для доступа к символу можно использовать <b>квадратные скобки</b>:
  var str = "Я - современный браузер!";
  alert( str[0] ); // "Я"
  alert( "".charAt(0) ); // пустая строка
  alert( "" [0] ); // undefined  
  //Разница между этим способом и charAt заключается в том, что если символа нет – charAt выдает пустую строку, а скобки – undefined:
  //Доступ к символам – str.charAt(позиция);
  var str = "jQuery";
  alert( str.charAt(0) ); // "j" - возращает строку из одного символа. Первый символ имеет позицию 0

  // toLowerCase() и toUpperCase() 
  alert( "Интерфейс".toUpperCase() ); // ИНТЕРФЕЙС
  // Пример ниже получает первый символ и приводит его к нижнему регистру:
  alert( "Интерфейс"[0].toLowerCase() ); // 'и'

  // <b>indexOf(подстрока[, начальная_позиция]) и lastIndexOf (ищет с конца строки)</b>
  // для поиска подстроки. Метод возвращает позицию, на которой находится подстрока или -1, если ничего не найдено. 
  var str = "Widget with id";
  console.log(str.indexOf("Widget")); // 0, т.к. "Widget" найден прямо в начале str
  console.log(str.indexOf("id")); // 1, т.к. "id" найден, начиная с позиции 1
  console.log(str.indexOf("widget")); // -1, не найдено, так как поиск учитывает регистр
  // Необязательный второй аргумент позволяет искать, начиная с указанной позиции. Например, первый раз "id" появляется на позиции 1. Чтобы найти его следующее появление – запустим поиск с позиции 2:
  var str = "Widget with id";
  console.log(str.indexOf("id", 2)) // 12, поиск начат с позиции 2

  // <b>Поиск всех вхождений</b>
  // Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Как только получаем очередную позицию – начинаем следующий поиск со следующей. Такой цикл начинает поиск с позиции 0, затем найдя подстроку на позиции foundPos, следующий поиск продолжит с позиции pos = foundPos+1, и так далее, пока что-то находит.
  var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке
  var target = "Иа"; // цель поиска
  var pos = 0;
  while (true) {
    var foundPos = str.indexOf(target, pos);
    if (foundPos == -1) break;
    alert( foundPos ); // нашли на этой позиции
    pos = foundPos + 1; // продолжить поиск со следующей
  }
  // Впрочем, тот же алгоритм можно записать и короче:
  var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке
  var target = "Иа"; // цель поиска
  var pos = -1;
  while ((pos = str.indexOf(target, pos + 1)) != -1) {
    alert(pos);
  }

  // <b>Копирование подстроки / взятие подстроки</b>: substring(start [, end]) или substr(start [, length - кол. элементов]) и <b>slice(start [, end])</b>. Ниже описан метод slice() как самый удобный в использовании
  // Возвращает часть строки от позиции start до позиции end не включая самой позиции end. Если аргумент end отсутствует, то идет до конца строки. Отрицательные значения отсчитываются от конца строки.
  alert( "testme".slice(-2) ); // "me", от 2 позиции с конца
  alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.
  var str = 'The quick red fox jumped over the lazy dog\'s back.';
  console.log(str.slice(30)); // expected output: "the lazy dog's back."
  console.log(str.slice(4, 17)); // expected output: "quick red fox"
  console.log(str.slice(-5)); // expected output: "back."
  console.log(str.slice(-11, -6)); // expected output: "dog's"
  <b>string.replace('abcd','efgh')</b>

  // <b>убрать лишние пробелы - trim()</b>, trimLeft(), trimRight()
  var string = "  Hello world";
  console.debug(string.trimLeft()); // prints "Hello world"

  <b>string.repeat(number)</b> - повторение нужного текста

  <b>array.split(s[,n])</b> - строка в массив по разделителю s, n - ограничение по количеству элементов
  var array = 'abcdefghijklmn';
  console.log(array.split('c')); // ["ab", "defghijklmn"]
  console.log(array.split('')); // вернёт ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n"]
  
  // <b>переворачиваю строку</b>
  function strRev(str) {
    return str.split('').reverse().join('');
  }
</pre>
      </section>
    </section>


    <section class="content-section" id="closures">
      <h3>Замыкания, область видимости</h3>
      <section>
        <h4>Общее</h4>
        <p>В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется «глобальный объект» (global object). В браузере этот объект явно доступен под именем window. Объект window одновременно является глобальным объектом и содержит ряд свойств и методов для работы с окном браузера. Присваивая или читая глобальную переменную, мы, фактически, работаем со свойствами window. Создать переменную можно и явным присваиванием в window:</p>
<pre>
  var a = 5; // объявление var создаёт свойство window.a
  alert( window.a ); // 5
  window.a = 6;
  alert( a ); // 6
</pre>
      </section>
      <section>
        <h4>Порядок инициализации</h4>
        <p>На первой фазе происходит инициализация, подготовка к запуску. Во время инициализации скрипт сканируется на предмет объявления функций вида Function Declaration, а затем – на предмет объявления переменных var. Каждое такое объявление добавляется в window. Функции, объявленные как Function Declaration, создаются сразу работающими, а переменные – равными undefined. Потом происходит выполнение кода. В коде ниже указано содержание глобального объекта на момент инициализации и далее последовательно по коду:</p>
<pre>
  // На момент инициализации, до выполнения кода:
  // window = { f: function, a: undefined, g: undefined }
  var a = 5;
  // window = { f: function, a: 5, g: undefined }
  function f(arg) { /*...*/ }
  // window = { f: function, a: 5, g: undefined } без изменений, f обработана ранее
  var g = function(arg) { /*...*/ };
  // window = { f: function, a: 5, g: function }
  Кстати, тот факт, что к началу выполнения кода переменные и функции уже содержатся в window, можно легко проверить, выведя их:
  alert("a" in window); // true,  т.к. есть свойство window.a
  alert(a); // равно undefined,  присваивание будет выполнено далее
  alert(f); // function ...,  готовая к выполнению функция
  alert(g); // undefined, т.к. это переменная, а не Function Declaration
  var a = 5;
  function f() { /*...*/ }
  var g = function() { /*...*/ };
</pre>
        <p>Фигурные скобки, которые используются в for, while, if, в отличие от объявлений функции, имеют «декоративный» характер.</p>
      </section>
      <section>
        <h4>Лексическое окружение</h4>
        <p>Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске. Будем называть этот объект «лексическое окружение» или просто «объект переменных». При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения. В отличие от window, объект LexicalEnvironment является внутренним, он скрыт от прямого доступа.</p>
<pre>
  // Пример
  Посмотрим пример, чтобы лучше понимать, как это работает:
  function sayHi(name) {
    var phrase = "Привет, " + name;
    alert( phrase );
  }
  sayHi('Вася');
</pre>
        <p>
          При вызове функции:
          1. До выполнения первой строчки её кода, на стадии инициализации, интерпретатор создает пустой объект LexicalEnvironment и заполняет его.
          В данном случае туда попадает аргумент name и единственная переменная phrase:
        </p>
<pre>
  function sayHi(name) {
    // LexicalEnvironment = { name: 'Вася', phrase: undefined }
    var phrase = "Привет, " + name;
    alert( phrase );
  }
  sayHi('Вася');            
</pre>
        <p>2. Функция выполняется. Во время выполнения происходит присвоение локальной переменной phrase, то есть, другими словами, присвоение свойству LexicalEnvironment.phrase нового значения:</p>
<pre>
  function sayHi(name) {
    // LexicalEnvironment = { name: 'Вася', phrase: undefined }
    var phrase = "Привет, " + name;
    // LexicalEnvironment = { name: 'Вася', phrase: 'Привет, Вася'}
    alert( phrase );
  }
  sayHi('Вася');    
</pre>
        <p>3. В конце выполнения функции объект с переменными обычно выбрасывается и память очищается. В примерах выше так и происходит.</p>
      </section>
      <section>
        <h4>Доступ ко внешним переменным</h4>
        <p>Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем LexicalEnvironment, а затем, если её нет – ищет во внешнем объекте переменных. В данном случае им является window. Такой порядок поиска возможен благодаря тому, что ссылка на внешний объект переменных хранится в специальном внутреннем свойстве функции, которое называется [[Scope]]. Это свойство закрыто от прямого доступа, но знание о нём очень важно для понимания того, как работает JavaScript.</p>
<pre>
  var userName = "Вася";
  function sayHi() {
    alert( userName ); // "Вася"
  }            
</pre>
        <p class="important">Важно:</p>
        <p>При создании функция получает скрытое свойство [[Scope]], которое ссылается на лексическое окружение, в котором она была создана. В примере выше таким окружением является window, так что создаётся свойство:</p>
<pre>
  sayHi.[[Scope]] = window
</pre>
        <p>При запуске функции её объект переменных LexicalEnvironment получает ссылку на «внешнее лексическое окружение» со значением из [[Scope]]. Если переменная не найдена в функции – она будет искаться снаружи.</p>
        <p>Всегда текущее значение. Значение переменной из внешней области берётся всегда текущее. Оно может быть уже не то, что было на момент создания функции.</p>
<pre>
  var phrase = 'Привет';
  function sayHi(name) {
    alert(phrase + ', ' + name);
  }
  sayHi('Вася');  // Привет, Вася (*)
  phrase = 'Пока';
  sayHi('Вася'); // Пока, Вася (**)            
</pre>
        <p> На момент первого запуска (*), переменная phrase имела значение 'Привет', а ко второму (**) изменила его на 'Пока'.</p>
      </section>
      <section>
        <h4>Вложенные функции</h4>
        <p>Внутри функции можно объявлять не только локальные переменные, но и другие функции:</p>
<pre>
  function sayHiBye(firstName, lastName) {
    alert( "Привет, " + getFullName() );
    alert( "Пока, " + getFullName() );
    function getFullName() {
      return firstName + " " + lastName;
    }
  }
  sayHiBye("Вася", "Пупкин"); // Привет, Вася Пупкин ; Пока, Вася Пупкин
  // Здесь, для удобства, создана вспомогательная функция getFullName().
</pre>
        <p>Вложенные функции получают [[Scope]] так же, как и глобальные. В нашем случае: getFullName.[[Scope]] = <b>объект переменных текущего запуска sayHiBye</b></p>
        <p>Заметим, что если переменная не найдена во внешнем объекте переменных, то она ищется в ещё более внешнем (через [[Scope]] внешней функции), то есть, такой пример тоже будет работать:</p>
<pre>
  var phrase = 'Привет';
  function say() {
    function go() {
      alert( phrase ); // найдёт переменную снаружи
    }
  
    go();
  }
  say();            
</pre>
      </section>
      <section>
        <h4>Возврат функции</h4>
        <p>Рассмотрим более «продвинутый» вариант, при котором внутри одной функции создаётся другая и возвращается в качестве результата.</p>
<pre>
  function makeCounter() {
    // LexicalEnvironment = { currentCount: undefined }
    var currentCount = 1;
    // LexicalEnvironment = { currentCount: 1 }
    return function() { // (**) // [[Scope]] -> LexicalEnvironment (**)
      return currentCount++;
    };
  }
  var counter = makeCounter(); // (*)
  // каждый вызов увеличивает счётчик и возвращает результат
  alert( counter() ); // 1, [[Scope]] -> {currentCount: 1}
  alert( counter() ); // 2, [[Scope]] -> {currentCount: 2}
  alert( counter() ); // 3, [[Scope]] -> {currentCount: 3}
  // создать другой счётчик, он будет независим от первого
  var counter2 = makeCounter();
  alert( counter2() ); // 1      
  
  // делал сам - постарайся объяснить код!

  // Префиксная форма:
  // function makeCounter() { 
  //   var currentCount = 1;
  //   return function() { // возвращаем функцию из функции
  //     var newNum = ++currentCount; 
  //     return newNum;
  //   };
  // }
  // var counter = makeCounter(); // записываем замыкание в переменную. 
  // console.log(counter()); // 2
  // console.log(counter()); // 3
  // console.log(counter()); // 4
  // console.log('____');
  
  // function makeCounter() { 
  //   var currentCount = 1;
  //   return function() { // возвращаем функцию из функции
  //     currentCount++; 
  //     return currentCount;
  //   };
  // }
  // var counter = makeCounter(); // записываем замыкание в переменную. 
  // console.log(counter()); // 2
  // console.log(counter()); // 3
  // console.log(counter()); // 4
  // console.log('____');
  
  function makeCounter() { 
    var currentCount = 1;
    return function() { // возвращаем функцию из функции
      return currentCount++;
    };
  }
  var counter = makeCounter(); // записываем замыкание в переменную. 
  console.log(counter()); // 1
  console.log(counter()); // 2
  console.log(counter()); // 3
  console.log('____');  
</pre>
        <p>Как видно, мы получили два независимых счётчика counter и counter2, каждый из которых незаметным снаружи образом сохраняет текущее количество вызовов. Где? Конечно, во внешней переменной currentCount, которая у каждого счётчика своя.</p>
        <p>1. В строке (*) запускается makeCounter(). При этом создаётся LexicalEnvironment для переменных текущего вызова. В функции есть одна переменная var currentCount, которая станет свойством этого объекта. Она изначально инициализуется в undefined, затем, в процессе выполнения, получит значение 1.<br>
        2. В процессе выполнения makeCounter() создаёт функцию в строке (**). При создании эта функция получает внутреннее свойство [[Scope]] со ссылкой на текущий LexicalEnvironment.<br>
        3. Далее вызов makeCounter() завершается и функция (**) возвращается и сохраняется во внешней переменной counter (*). Итоговым значением, записанным в переменную counter, является функция:
        </p>
<pre>
  function() { // [[Scope]] -> {currentCount: 1}
    return currentCount++;
  };
</pre>
      </section>
      <section>
        <h4>Свойства функции</h4>
        <p>Функция в JavaScript является объектом, поэтому можно присваивать свойства прямо к ней, вот так:</p>
<pre>
    function f() {}
    f.test = 5;
    alert( f.test );            
</pre>
        <p>Свойства функции не стоит путать с переменными и параметрами. Они совершенно никак не связаны. Переменные доступны только внутри функции, они создаются в процессе её выполнения. Это – использование функции «как функции». А свойство у функции – доступно отовсюду и всегда. Это – использование функции «как объекта».</p>
      </section>
      <section>
        <h4>Замыкания</h4>
        <p>Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны. «Понимать замыкания» в JavaScript означает понимать следующие вещи:</p>
        <p>1. Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window.</p>
        <p>2. При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана.</p>
        <p>3. При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».</p>
        <p class="important">Важно:</p>
        <p>При создании функции с использованием new Function, её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window.</p>
        <p>Улучшим счётчик, который создавали выше - перейдем на полноценный объект:</p>
<pre>
  function makeCounter() {
    var currentCount = 1;
    return { // возвратим объект вместо функции
      getNext: function() {
        return currentCount++;
      },
      set: function(value) {
        currentCount = value;
      },
      reset: function() {
        currentCount = 1;
      }
    };
  }
  var counter = makeCounter();
  alert( counter.getNext() ); // 1
  alert( counter.getNext() ); // 2
  counter.set(5);
  alert( counter.getNext() ); // 5            
</pre>
        <p>К сожалению, при переходе на объект короткий вызов пропал, вместо него теперь counter.getNext(), давайте вернём его!</p>
<pre>
  function makeCounter() {
    var currentCount = 1;
  
    // возвращаемся к функции
    function counter() {
      return currentCount++;
    }
    // ...и добавляем ей методы!
    counter.set = function(value) {
      currentCount = value;
    };
    counter.reset = function() {
      currentCount = 1;
    };
    return counter;
  }
  var counter = makeCounter();
  alert( counter() ); // 1
  alert( counter() ); // 2
  counter.set(5);
  alert( counter() ); // 5            
</pre>
      </section>
      <section>
        <h4>Задания</h4>
        <ol class="ordered-list-restored">
          <li>
            <p>Что будет, если вызов say('Вася'); стоит в самом-самом начале, в первой строке кода?</p>
<pre>
  say('Вася'); // Что выведет? Не будет ли ошибки?
  var phrase = 'Привет';
  function say(name) {
    alert( name + ", " + phrase );
  }
</pre>
            <label class="question" for="closures1">Показать ответ</label>
            <input type="checkbox" id="closures1" class="visually-hidden">
            <p>Ошибки не будет, выведет "Вася, undefined". Переменная как таковая существует, вот только на момент запуска функции она равна undefined.</p>
          </li>
          <li>
            <p>Каков будет результат выполнения этого кода? Изменится ли внешняя переменная value ? Какими будут ответы, если из строки var value = false убрать var?</p>
<pre>
  var value = 0;
  function f() {
    if (1) {
      value = true;
    } else {
      var value = false;
    }
    alert( value );
  }
  f();
</pre>
            <label class="question" for="closures2">Показать ответ</label><input type="checkbox" id="closures2" class="visually-hidden"> 
            <p>Результатом будет true, т.к. var обработается и переменная будет создана до выполнения кода. Соответственно, присвоение value=true сработает на локальной переменной, и alert выведет true. Внешняя переменная не изменится. P.S. Если var нет, то в функции переменная не будет найдена. Интерпретатор обратится за ней в window и изменит её там. Так что без var результат будет также true, но внешняя переменная изменится.</p>
          </li>
          <li>
            <p>Каков будет результат выполнения этого кода? Почему?</p>
<pre>
  function test() {
    alert( window );
    var window = 5;
    alert( window );
  }
  test();
</pre>
            <label class="question" for="closures3">Показать ответ</label><input type="checkbox" id="closures3" class="visually-hidden"> 
            <p>Результатом будет undefined, затем 5.</p>
          </li>
          <li>
            <p>Если во внутренней функции есть своя переменная с именем currentCount – можно ли в ней получить currentCount из внешней функции?</p>
<pre>
  function makeCounter() {
    var currentCount = 1;
  
    return function() {
      var currentCount;
      // можно ли здесь вывести currentCount из внешней функции (равный 1)?
    };
  }
</pre>
            <label class="question" for="closures4">Показать ответ</label><input type="checkbox" id="closures4" class="visually-hidden"> 
            <p>Нет. Локальная переменная полностью перекрывает внешнюю.</p>
          </li>
          <li>
            <p>Что выведут эти вызовы, если переменная currentCount находится вне makeCounter?</p>
<pre>
  var currentCount = 1;
  function makeCounter() {
    return function() {
      return currentCount++;
    };
  }
  var counter = makeCounter();
  var counter2 = makeCounter();
  
  alert( counter() ); // ?
  alert( counter() ); // ?
  alert( counter2() ); // ?
  alert( counter2() ); // ?
</pre>
            <label class="question" for="closures5">Показать ответ</label><input type="checkbox" id="closures5" class="visually-hidden">
            <p>Выведут 1,2,3,4. Здесь внутренняя функция будет искать – и находить currentCount каждый раз в самом внешнем объекте переменных: глобальном объекте window. В результате все счётчики будут разделять единое, глобальное текущее значение.</p>
          </li>
          <li>
            <p>Напишите функцию sum, которая работает так: sum(a)(b) = a+b. Да, именно так, через двойные скобки (это не опечатка). Например:</p>
<pre>
  // sum(1)(2) = 3
  // sum(5)(-1) = 4                
</pre>
            <label class="question" for="closures6">Показать ответ</label><input type="checkbox" id="closures6" class="visually-hidden">
<pre>
  function sum(a) {
    return function(b) {
      return a + b
    }
  }
  var some = sum(5)(-2);
  console.log(some);    
</pre>
          </li>
          <li>
            <p>
                <img src="images/closures__1.png" alt="closures__1">
            </p>  
<pre>
  // код, от которого можно отталкиваться
  // function makeBuffer() { /* ваш код */ }
  // var buffer = makeBuffer();
  // // добавить значения к буферу
  // buffer('Замыкания');
  // buffer(' Использовать');
  // buffer(' Нужно!');
  // // получить текущее значение
  // alert( buffer() ); // Замыкания Использовать Нужно!         
</pre>
            <label class="question" for="closures7">Показать ответ</label><input type="checkbox" id="closures7" class="visually-hidden">  
<pre>
  // 1
  function makeBuffer() {
    var value = '';
    return function(newInfo) {
            if (newInfo || newInfo === 0) {
              value += newInfo;
              return value;
            } 
            return value;
          }
  }
  var buffer = makeBuffer();
  buffer('Замыкания');
  console.log(buffer());
  buffer(' Использовать');
  buffer(' Нужно!');
  console.log(buffer()); 
  // Буфер должен преобразовывать все данные к строковому типу:
  var buffer2 = makeBuffer();
  buffer2(0);
  buffer2(1);
  buffer2(0);
  console.log(buffer2()); // '010'                

  // 2
  function makeBuffer() { 
    var stringBuffer = '';
    return function addInfo() {
             if (arguments.length > 0) {
               for (var i = 0; i &lt; arguments.length; i ++) {
                 stringBuffer += arguments[i] + ' ';
               }
             }
             return stringBuffer;
           }
  }
  
  var buffer = makeBuffer(); // сохраняем результат внешней функции - передаёйтся вся функция
  console.log(buffer); 
  // добавить значения к буферу
  buffer('Замыкания');  // вызываем результат внешней функции с параметром - она же вложенная функция
  buffer('Использовать ОЧЕНЬ');
  buffer('Нужно!');
  // получить текущее значение
  console.log( buffer() ); // Замыкания Использовать Нужно!   
</pre>
          </li>
          <li>
            <p>Добавьте буферу из решения задачи №7 метод buffer.clear(), который будет очищать текущее содержимое буфера:</p>
            <label class="question" for="closures8">Показать ответ</label><input type="checkbox" id="closures8" class="visually-hidden">
<pre>
    function makeBuffer() { 
      var stringBuffer = '';
      function addInfo() {
        if (arguments.length !== 0) {
          for (var i = 0; i &lt; arguments.length; i ++) {
            stringBuffer += arguments[i] + ' ';
          }
        }
        return stringBuffer; // возвращаю буфер (если есть аргументы - добавляю их)
      }
      addInfo.clear = function() {
        return stringBuffer = ''; // свойство функции addInfo для очистки себя -- или без return?
      }
      return addInfo;
    }
    
    var buffer = makeBuffer(); // сохраняем результат внешней функции - передаёйтся вся функция
    console.log(buffer); 
    // добавить значения к буферу
    buffer('Замыкания');  // вызываем результат внешней функции с параметром - она же вложенная функция
    buffer('Использовать ОЧЕНЬ');
    buffer.clear();
    buffer('Нужно!');
    // получить текущее значение
    console.log( buffer() ); // Замыкания Использовать Нужно!            
</pre>
          </li>
          <li>
            <p>
              <img src="images/closures__2.png" alt="closures__2">
            </p>
<pre>
  // код, которым можно проверить правильность ответа
  users.sort(byField('name'));
  users.forEach(function(user) {
    console.log(user.name);
  }); // Вася, Маша, Петя

  users.sort(byField('age'));
  users.forEach(function(user) {
    console.log(user.age);
  }); // Маша, Вася, Петя
</pre>
            <label class="question" for="closures9">Показать ответ</label><input type="checkbox" id="closures9" class="visually-hidden">
<pre>
  function byField(fieldName) {
    return function(a, b) { // передаю сюда функцию с a и b, потому что sort принимает функцию с двумя параменрами
      return a[fieldName] > b[fieldName] ? 1 : -1;
    }
  }
  users.sort(byField('name'));
  users.forEach(function(user) {
    console.log(user.name);
  }); // Вася, Маша, Петя
  console.log('**');
  users.sort(byField('age'));
  users.forEach(function(user) {
    console.log(user.age);
  }); // Вася, Маша, Петя
  console.log('____');
</pre>
          </li>
          <li>
            <p>
              <img src="images/closures__3.png" aLT="closures__3">
            </p>
            <label class="question" for="closures10">Показать ответ</label><input type="checkbox" id="closures10" class="visually-hidden">
<pre>
  function filter(arraySample, functionSample) {
    var newArray = []; // создаю новый массив, который буду формировать
    arraySample.forEach(function(item) { // проверяю каждое значения массива, который дан изначально
      if (functionSample(item)) { // если для элемента функция фозвращает правду, то добавляю элемент в новый массив
        newArray.push(item);
      }
    });
    return newArray; // возврвщаю массив
  }
  
  function inBetween(a,b) { // функция - параменты это крайние значения
    return function(item) { // другая функция для переменной с элементом
      return a &lt; = item && item >= b;
    };
  }
  function inArray(arr) {
    return function(item) {
      return arr.indexOf(item) != -1;
    };
  }
  
  var arr = [1, 2, 3, 4, 5, 6, 7];
  // передаю в функцию массив с числами от 1 до 7 и функцию, которая возвращает правду для выполненого условия
  console.log(filter(arr, function(a) { return a % 2 == 0 })); // [2,4,6]
  console.log( filter(arr, inBetween(3, 6)) ); // [3,4,5,6]
  console.log( filter(arr, inArray([1, 2, 10])) ); // [1,2]
  console.log('__');                
</pre>
          </li>
          <li>
            <p>Армия функций</p>
          </li>
        </ol>
      </section>
    </section>




    <a href="#to-top" class="button-scroll"></a>
	</main>
  
  <script src="script.js"></script>
</body>
</html>